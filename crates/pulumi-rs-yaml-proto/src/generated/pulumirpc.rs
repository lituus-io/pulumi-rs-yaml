// This file is @generated by prost-build.
/// PluginInfo is meta-information about a plugin that is used by the system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginInfo {
    /// the semver for this plugin.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
/// PluginDependency is information about a plugin that a program may depend upon.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginDependency {
    /// the name of the plugin.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the kind of plugin (e.g., language, etc).
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// the semver for this plugin.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// the URL of a server that can be used to download this plugin, if needed.
    #[prost(string, tag = "4")]
    pub server: ::prost::alloc::string::String,
    /// a map of the checksums for the plugin, will be empty from old language runtimes. The keys should match
    /// the os and architecture names used in pulumi releases, e.g. "darwin-amd64", "windows-arm64".
    #[prost(map = "string, bytes", tag = "5")]
    pub checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// PluginAttach is used to attach an already running plugin to the engine.
///
/// Normally the engine starts the plugin process itself and passes the engine address as the first argumnent.
/// But when debugging it can be useful to have an already running provider that the engine instead attaches
/// to, this message is used so the provider can still be passed the engine address to communicate with.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginAttach {
    /// the grpc address for the engine
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageParameterization {
    /// the parameterized package name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the parameterized package version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the parameter value for the parameterized package.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// PackageDependency is information about a package that a program may depend upon.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageDependency {
    /// the name of the plugin.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the kind of plugin (e.g., language, etc).
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// the semver for this plugin.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// the URL of a server that can be used to download this plugin, if needed.
    #[prost(string, tag = "4")]
    pub server: ::prost::alloc::string::String,
    /// a map of the checksums for the plugin, will be empty from old language runtimes. The keys should match
    /// the os and architecture names used in pulumi releases, e.g. "darwin-amd64", "windows-arm64".
    #[prost(map = "string, bytes", tag = "5")]
    pub checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// The optional parameterization for this package.
    #[prost(message, optional, tag = "6")]
    pub parameterization: ::core::option::Option<PackageParameterization>,
}
/// A `ProgramInfo` struct specifies a Pulumi program, and is built typically based on the location of a `Pulumi.yaml`
/// file and the `runtime`, `main` and other properties within that file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgramInfo {
    /// The root of the project containing the program, where the `Pulumi.yaml` file is located. This should be an
    /// absolute path on the filesystem that is accessible to the language host.
    #[prost(string, tag = "1")]
    pub root_directory: ::prost::alloc::string::String,
    /// The directory containing the program to execute (e.g. the location of the `index.ts` for a TypeScript NodeJS
    /// program). This should be an absolute path on the filesystem that is accessible to the language host. If
    /// `ProgramInfo` is being built from a `Pulumi.yaml`, this will typically be the directory portion of the `main`
    /// property in that file.
    #[prost(string, tag = "2")]
    pub program_directory: ::prost::alloc::string::String,
    /// The entry point of the program to execute. This should be a relative path from the `program_directory`, and is
    /// often just `.` to indicate the program directory itself, but it can also be a filename inside the directory.. If
    /// `ProgramInfo` is being built from a `Pulumi.yaml`, this will typically be the filename specified `main` property
    /// in that file if it is present, or the aforementioned `.` if not.
    #[prost(string, tag = "3")]
    pub entry_point: ::prost::alloc::string::String,
    /// A struct capturing any language-specific options. If `ProgramInfo` is being built from a `Pulumi.yaml`, this will
    /// contain the `runtime.options` property from that file.
    #[prost(message, optional, tag = "4")]
    pub options: ::core::option::Option<::prost_types::Struct>,
}
/// `AboutRequest` is the type of requests sent as part of an [](pulumirpc.LanguageRuntime.About) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AboutRequest {
    /// The program to use.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ProgramInfo>,
}
/// `AboutResponse` is the type of responses sent by an [](pulumirpc.LanguageRuntime.About) call. It contains information
/// about the language runtime being used.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AboutResponse {
    /// The primary executable for the runtime of this language. This should be an absolute path. E.g. for NodeJS on a
    /// POSIX system, this might be something like `/usr/bin/node`.
    #[prost(string, tag = "1")]
    pub executable: ::prost::alloc::string::String,
    /// The version of the runtime underpinning the language host. E.g. for a NodeJS host, this might be the version of
    /// `node` being used.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Other host-specific metadata about the runtime underpinning the language host.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// `GetProgramDependenciesRequest` is the type of requests sent as part of a
/// [](pulumirpc.LanguageRuntime.GetProgramDependencies) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramDependenciesRequest {
    /// The project name.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field. Newer
    /// versions of the engine will always set this field to the string `"deprecated"`.
    /// :::
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// The program's working directory.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `program_directory` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "2")]
    pub pwd: ::prost::alloc::string::String,
    /// The path to the program.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `entry_point` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "3")]
    pub program: ::prost::alloc::string::String,
    /// True if transitive dependencies should be included in the response.
    #[prost(bool, tag = "4")]
    pub transitive_dependencies: bool,
    /// The program to use.
    #[prost(message, optional, tag = "5")]
    pub info: ::core::option::Option<ProgramInfo>,
}
/// `DependencyInfo` is a struct that captures information about a language-specific dependency required by a program
/// (e.g. an NPM package for NodeJS, or a Maven library for Java). It is returned as part of a
/// [](pulumirpc.LanguageRuntime.GetProgramDependenciesResponse).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyInfo {
    /// The name of the dependency.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the dependency.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// `GetProgramDependenciesResponse` is the type of responses sent by a
/// [](pulumirpc.LanguageRuntime.GetProgramDependencies) call. It contains information about the dependencies of a
/// program.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramDependenciesResponse {
    /// The dependencies of the program specified by the request.
    #[prost(message, repeated, tag = "1")]
    pub dependencies: ::prost::alloc::vec::Vec<DependencyInfo>,
}
/// `GetRequiredPluginsRequest` is the type of requests sent as part of a
/// [](pulumirpc.LanguageRuntime.GetRequiredPlugins) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequiredPluginsRequest {
    /// The project name.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field. Newer
    /// versions of the engine will always set this field to the string `"deprecated"`.
    /// :::
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// The program's working directory.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `program_directory` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "2")]
    pub pwd: ::prost::alloc::string::String,
    /// The path to the program.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `entry_point` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "3")]
    pub program: ::prost::alloc::string::String,
    /// The program to use.
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<ProgramInfo>,
}
/// `GetRequiredPluginsResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.GetRequiredPlugins)
/// call. It contains information about the plugins required by a program.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequiredPluginsResponse {
    /// The plugins required by the program specified by the request.
    #[prost(message, repeated, tag = "1")]
    pub plugins: ::prost::alloc::vec::Vec<PluginDependency>,
}
/// `GetRequiredPackagesRequest` is the type of requests sent as part of a
/// [](pulumirpc.LanguageRuntime.GetRequiredPackages) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequiredPackagesRequest {
    /// The program to use.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ProgramInfo>,
}
/// `GetRequiredPackagesResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.GetRequiredPackages)
/// call. It contains information about the packages required by a program.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRequiredPackagesResponse {
    /// The packages required by the program specified by the request.
    #[prost(message, repeated, tag = "1")]
    pub packages: ::prost::alloc::vec::Vec<PackageDependency>,
}
/// `RunRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.Run) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunRequest {
    /// The project name.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// The name of the stack being deployed into.
    #[prost(string, tag = "2")]
    pub stack: ::prost::alloc::string::String,
    /// The program's working directory.
    #[prost(string, tag = "3")]
    pub pwd: ::prost::alloc::string::String,
    /// The path to the program.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `entry_point` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "4")]
    pub program: ::prost::alloc::string::String,
    /// Any arguments to pass to the program.
    #[prost(string, repeated, tag = "5")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Configuration variables to apply before running the program.
    #[prost(map = "string, string", tag = "6")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// True if we are only doing a dry run (preview).
    #[prost(bool, tag = "7")]
    pub dry_run: bool,
    /// The degree of parallelism that should be used for resource operations. A value less than or equal to 1 indicates
    /// serial execution.
    #[prost(int32, tag = "8")]
    pub parallel: i32,
    /// The address of the [](pulumirpc.ResourceMonitor) that the program should connect to send [resource
    /// registrations](resource-registration) and other calls to.
    #[prost(string, tag = "9")]
    pub monitor_address: ::prost::alloc::string::String,
    /// This is deprecated, query mode is no longer a supported feature.
    #[deprecated]
    #[prost(bool, tag = "10")]
    pub query_mode: bool,
    /// A list of configuration keys whose values should be treated as secrets.
    #[prost(string, repeated, tag = "11")]
    pub config_secret_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The organization of the stack being deployed into.
    #[prost(string, tag = "12")]
    pub organization: ::prost::alloc::string::String,
    /// This is deprecated, runtimes should look at the string based config as that maintains the full textual data from
    /// the users config file.
    #[deprecated]
    #[prost(message, optional, tag = "13")]
    pub config_property_map: ::core::option::Option<::prost_types::Struct>,
    /// The program to use.
    #[prost(message, optional, tag = "14")]
    pub info: ::core::option::Option<ProgramInfo>,
    /// The target of a codegen.LoaderServer to use for loading schemas.
    #[prost(string, tag = "15")]
    pub loader_target: ::prost::alloc::string::String,
    /// True if and only if the host should start the program under a debugger.
    #[prost(bool, tag = "16")]
    pub attach_debugger: bool,
}
/// `RunResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.Run) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunResponse {
    /// Information about any unhandled error that occurred during the run.
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    /// True if an error happened, but it was reported to the user. Work should halt immediately, reporting nothing
    /// further to the user (since this reporting has already happened). This corresponds to a `result.Bail()` value
    /// being raised in the Go application layer.
    #[prost(bool, tag = "2")]
    pub bail: bool,
}
/// `InstallDependenciesRequest` is the type of requests sent as part of an
/// [](pulumirpc.LanguageRuntime.InstallDependencies) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallDependenciesRequest {
    /// The program's working directory.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `program_directory` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "1")]
    pub directory: ::prost::alloc::string::String,
    /// True if we are running in a terminal and may use [ANSI escape
    /// codes](<https://en.wikipedia.org/wiki/ANSI_escape_code>) in our output.
    #[prost(bool, tag = "2")]
    pub is_terminal: bool,
    /// The program to use.
    #[prost(message, optional, tag = "3")]
    pub info: ::core::option::Option<ProgramInfo>,
    /// True if the host should use language-specific version managers, such as `pyenv` or `nvm`, to set up the version
    /// of the language toolchain used.
    #[prost(bool, tag = "4")]
    pub use_language_version_tools: bool,
    /// True if this install is for a plugin, as opposed to a top level Pulumi program.
    #[prost(bool, tag = "5")]
    pub is_plugin: bool,
}
/// `InstallDependenciesResponse` is the type of responses streamed by an
/// [](pulumirpc.LanguageRuntime.InstallDependencies) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallDependenciesResponse {
    /// A line of standard output.
    #[prost(bytes = "vec", tag = "1")]
    pub stdout: ::prost::alloc::vec::Vec<u8>,
    /// A line of standard error.
    #[prost(bytes = "vec", tag = "2")]
    pub stderr: ::prost::alloc::vec::Vec<u8>,
}
/// `RuntimeOptionsRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.RuntimeOptionsPrompts)
/// call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeOptionsRequest {
    /// The program to use.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ProgramInfo>,
}
/// `RuntimeOptionPrompt` is a struct that captures information about a runtime option that should be prompted for during
/// `pulumi new`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeOptionPrompt {
    /// A unique key that identifies the runtime option.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// A human-readable description of the runtime option.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The type of the runtime option.
    #[prost(enumeration = "runtime_option_prompt::RuntimeOptionType", tag = "3")]
    pub prompt_type: i32,
    /// A set of choices for the runtime option that may be displayed as part of the prompting process.
    #[prost(message, repeated, tag = "4")]
    pub choices: ::prost::alloc::vec::Vec<runtime_option_prompt::RuntimeOptionValue>,
    /// The default value of the runtime option.
    #[prost(message, optional, tag = "5")]
    pub default: ::core::option::Option<runtime_option_prompt::RuntimeOptionValue>,
}
/// Nested message and enum types in `RuntimeOptionPrompt`.
pub mod runtime_option_prompt {
    /// `RuntimeOptionValue` is a struct that captures the value of a runtime option.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeOptionValue {
        /// The type of the runtime option.
        #[prost(enumeration = "RuntimeOptionType", tag = "1")]
        pub prompt_type: i32,
        /// The string value of the runtime option, if and only if the type is `STRING`.
        #[prost(string, tag = "2")]
        pub string_value: ::prost::alloc::string::String,
        /// The 32-bit integer value of the runtime option, if and only if the type is `INT32`.
        #[prost(int32, tag = "3")]
        pub int32_value: i32,
        /// The display name of the runtime option, to be used in prompts.
        #[prost(string, tag = "4")]
        pub display_name: ::prost::alloc::string::String,
    }
    /// `RuntimeOptionType` is an enum that captures the type of a runtime option.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RuntimeOptionType {
        /// A string value.
        String = 0,
        /// A 32-bit integer value.
        Int32 = 1,
    }
    impl RuntimeOptionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::String => "STRING",
                Self::Int32 => "INT32",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STRING" => Some(Self::String),
                "INT32" => Some(Self::Int32),
                _ => None,
            }
        }
    }
}
/// `RuntimeOptionsResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.RuntimeOptionsPrompts) call.
/// It contains information about additional prompts to ask during `pulumi new`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeOptionsResponse {
    /// Prompts to ask the user.
    #[prost(message, repeated, tag = "1")]
    pub prompts: ::prost::alloc::vec::Vec<RuntimeOptionPrompt>,
}
/// `TemplateRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.Template) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateRequest {
    /// The [plugin program](pulumirpc.ProgramInfo) to use.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ProgramInfo>,
    /// The name of the project we are templating.
    #[prost(string, tag = "2")]
    pub project_name: ::prost::alloc::string::String,
}
/// `TemplateResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.Template) call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TemplateResponse {}
/// `RunPluginRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.RunPlugin) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunPluginRequest {
    /// The plugin program's working directory.
    #[prost(string, tag = "1")]
    pub pwd: ::prost::alloc::string::String,
    /// The path to the plugin program.
    ///
    /// :::{important}
    /// This is deprecated in favour of passing a [program info](pulumirpc.ProgramInfo) struct as the `info` field, with
    /// the `entry_point` field set to this value.
    /// :::
    #[deprecated]
    #[prost(string, tag = "2")]
    pub program: ::prost::alloc::string::String,
    /// Any arguments to pass to the plugin program.
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Any environment variables to set prior to executing the plugin program.
    #[prost(string, repeated, tag = "4")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The [plugin program](pulumirpc.ProgramInfo) to use.
    #[prost(message, optional, tag = "5")]
    pub info: ::core::option::Option<ProgramInfo>,
    /// The kind of plugin to run (resource/analyzer/etc).
    #[prost(string, tag = "6")]
    pub kind: ::prost::alloc::string::String,
    /// The name of the plugin (for display purposes)
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// True if a plugin should be started under a debugger.
    #[prost(bool, tag = "8")]
    pub attach_debugger: bool,
}
/// `RunPluginResponse` is the type of responses streamed by a [](pulumirpc.LanguageRuntime.RunPlugin) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunPluginResponse {
    #[prost(oneof = "run_plugin_response::Output", tags = "1, 2, 3")]
    pub output: ::core::option::Option<run_plugin_response::Output>,
}
/// Nested message and enum types in `RunPluginResponse`.
pub mod run_plugin_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Output {
        /// A line of standard output.
        #[prost(bytes, tag = "1")]
        Stdout(::prost::alloc::vec::Vec<u8>),
        /// A line of standard error.
        #[prost(bytes, tag = "2")]
        Stderr(::prost::alloc::vec::Vec<u8>),
        /// An exit code that the plugin program has terminated with. This should be the last message sent by the host.
        #[prost(int32, tag = "3")]
        Exitcode(i32),
    }
}
/// `GenerateProgramRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.GenerateProgram)
/// call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateProgramRequest {
    /// The source of the project, represented as a map of file names to [PCL](pcl) source code.
    #[prost(map = "string, string", tag = "1")]
    pub source: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The target of a codegen.LoaderServer to use for loading schemas.
    #[prost(string, tag = "2")]
    pub loader_target: ::prost::alloc::string::String,
    /// True if [PCL binding](pcl-binding) should be strict.
    #[prost(bool, tag = "3")]
    pub strict: bool,
}
/// `GenerateProgramResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.GenerateProgram) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateProgramResponse {
    /// Any diagnostics raised by code generation.
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<codegen::Diagnostic>,
    /// The generated program source code, represented as a map of file names to byte contents.
    #[prost(map = "string, bytes", tag = "2")]
    pub source: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// `GenerateProjectRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.GenerateProject) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateProjectRequest {
    /// The directory containing [PCL](pcl) source code, from which the project should be generated.
    #[prost(string, tag = "1")]
    pub source_directory: ::prost::alloc::string::String,
    /// The directory in which generated project files should be written. This should be an absolute path on the
    /// filesystem that is accessible to the language host.
    #[prost(string, tag = "2")]
    pub target_directory: ::prost::alloc::string::String,
    /// A string containing JSON to be used as the Pulumi project file (that is, as the contents of `Pulumi.yaml`).
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
    /// True if [PCL binding](pcl-binding) should be strict.
    #[prost(bool, tag = "4")]
    pub strict: bool,
    /// The target of a codegen.LoaderServer to use for loading schemas.
    #[prost(string, tag = "5")]
    pub loader_target: ::prost::alloc::string::String,
    /// Local dependencies that the generated project should reference explicitly, instead of e.g. using the language's
    /// package system. This is a map of package names to local paths of language-specific artifacts that should be used.
    /// For instance, in the case of a NodeJS project, this might be a map of NPM package names to local paths to be
    /// used, such as `{ "@pulumi/aws": "/some/path/to/aws.tgz" }` if a local tarball is to be used instead of the
    /// published `@pulumi/aws` package.
    #[prost(map = "string, string", tag = "6")]
    pub local_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// `GenerateProjectResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.GenerateProject) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateProjectResponse {
    /// Any diagnostics raised by code generation.
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<codegen::Diagnostic>,
}
/// `GeneratePackageRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.GeneratePackage) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneratePackageRequest {
    /// The directory to generate the package in. This should be an absolute path on the filesystem that is accessible to
    /// the language host.
    #[prost(string, tag = "1")]
    pub directory: ::prost::alloc::string::String,
    /// A JSON-encoded string containing the schema from which the SDK package should be generated.
    #[prost(string, tag = "2")]
    pub schema: ::prost::alloc::string::String,
    /// Extra files that should be copied as-is to the generated output.
    #[prost(map = "string, bytes", tag = "3")]
    pub extra_files: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// The target of a codegen.LoaderServer to use for loading schemas.
    #[prost(string, tag = "4")]
    pub loader_target: ::prost::alloc::string::String,
    /// Local dependencies that the generated package should reference explicitly, instead of e.g. using the language's
    /// package system. This is a map of package names to local paths of language-specific artifacts that should be used.
    /// For instance, in the case of a NodeJS package, this might be a map of NPM package names to local paths to be
    /// used, such as `{ "@pulumi/aws": "/some/path/to/aws.tgz" }` if a local tarball is to be used instead of the
    /// published `@pulumi/aws` package.
    #[prost(map = "string, string", tag = "5")]
    pub local_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// If true, generates an SDK appropriate for local usage. This may differ from a standard publishable SDK depending
    /// on the language (e.g. for a NodeJS package that is intended to be imported locally, the language host may choose
    /// not to generate a `package.json`).
    #[prost(bool, tag = "6")]
    pub local: bool,
}
/// `GeneratePackageResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.GeneratePackage) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneratePackageResponse {
    /// Any diagnostics raised by code generation.
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<codegen::Diagnostic>,
}
/// `PackRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.Pack) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackRequest {
    /// The directory containing the package to pack. This should be an absolute path on the filesystem that is accessible
    /// to the language host.
    #[prost(string, tag = "1")]
    pub package_directory: ::prost::alloc::string::String,
    /// The directory to write the packed artifact to. This should be an absolute path on the filesystem that is
    /// accessible to the language host.
    #[prost(string, tag = "2")]
    pub destination_directory: ::prost::alloc::string::String,
}
/// `PackResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.Pack) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackResponse {
    /// The path to the packed artifact. This should be an absolute path on the filesystem that is accessible to the
    /// language host.
    #[prost(string, tag = "1")]
    pub artifact_path: ::prost::alloc::string::String,
}
/// `LanguageHandshakeRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.Handshake) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanguageHandshakeRequest {
    /// The gRPC address of the engine calling the language host.
    #[prost(string, tag = "1")]
    pub engine_address: ::prost::alloc::string::String,
    /// The optional root directory, where the `PulumiPlugin.yaml` file or language binary is located. This can't be sent
    /// when the engine is attaching to a language via a port number.
    #[prost(string, optional, tag = "2")]
    pub root_directory: ::core::option::Option<::prost::alloc::string::String>,
    /// The optional absolute path to the directory of the language program to execute. Generally, but not required to
    /// be, underneath the root directory. This can't be sent when the engine is attaching to a language via a port
    /// number.
    #[prost(string, optional, tag = "3")]
    pub program_directory: ::core::option::Option<::prost::alloc::string::String>,
}
/// `LanguageHandshakeResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.Handshake) call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanguageHandshakeResponse {}
/// `LinkRequest` is the type of requests sent as part of a [](pulumirpc.LanguageRuntime.Link) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkRequest {
    /// The program to use.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<ProgramInfo>,
    /// The target of a codegen.LoaderServer to use for loading schemas.
    #[prost(string, tag = "2")]
    pub loader_target: ::prost::alloc::string::String,
    /// Local dependencies that should be linked into the program or plugin's language specific project files.
    /// Each dependency has a path to a language specific artifact. This can be a binary artifact like a
    /// Python wheel or a tar.gz for Node.js, or a source directory.
    #[prost(message, repeated, tag = "3")]
    pub packages: ::prost::alloc::vec::Vec<link_request::LinkDependency>,
}
/// Nested message and enum types in `LinkRequest`.
pub mod link_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinkDependency {
        #[prost(message, optional, tag = "1")]
        pub package: ::core::option::Option<super::PackageDependency>,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
    }
}
/// `LinkResponse` is the type of responses sent by a [](pulumirpc.LanguageRuntime.Link) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkResponse {
    /// The instructions on how to use a linked package in a program or plugin. These instructions are meant
    /// to be displayed to the user. For example when linking a local Python dependency, this might return
    /// `import my_namespace_mypkg as mypkg`.
    #[prost(string, tag = "1")]
    pub import_instructions: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod language_runtime_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The LanguageRuntime service defines a standard interface for [language hosts/runtimes](languages). At a high level, a
    /// language runtime provides the ability to execute programs, install and query dependencies, and generate code for a
    /// specific language.
    #[derive(Debug, Clone)]
    pub struct LanguageRuntimeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LanguageRuntimeClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LanguageRuntimeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LanguageRuntimeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LanguageRuntimeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// `Handshake` is the first call made by the engine to a language host. It is used to pass the engine's address to
        /// the language host so that it may establish its own connections back, and to establish protocol configuration that
        /// will be used to communicate between the two parties.
        pub async fn handshake(
            &mut self,
            request: impl tonic::IntoRequest<super::LanguageHandshakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LanguageHandshakeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/Handshake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "Handshake"));
            self.inner.unary(req, path, codec).await
        }
        /// `GetRequiredPlugins` computes the complete set of anticipated [plugins](plugins) required by a Pulumi program.
        /// Among other things, it is intended to be used to pre-install plugins before running a program with
        /// [](pulumirpc.LanguageRuntime.Run), to avoid the need to install them on-demand in response to [resource
        /// registrations](resource-registration) sent back from the running program to the engine.
        ///
        /// :::{important}
        /// The use of `GetRequiredPlugins` is deprecated in favour of [](pulumirpc.LanguageRuntime.GetRequiredPackages),
        /// which returns more granular information about which plugins are required by which packages.
        /// :::
        #[deprecated]
        pub async fn get_required_plugins(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequiredPluginsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRequiredPluginsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GetRequiredPlugins",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.LanguageRuntime", "GetRequiredPlugins"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// `GetRequiredPackages` computes the complete set of anticipated [packages](pulumirpc.PackageDependency) required
        /// by a program. It is used to pre-install packages before running a program with [](pulumirpc.LanguageRuntime.Run),
        /// to avoid the need to install them on-demand in response to [resource registrations](resource-registration) sent
        /// back from the running program to the engine. Moreover, when importing resources into a stack, it is used to
        /// determine which plugins are required to service the import of a given resource, since given the presence of
        /// [parameterized providers](parameterized-providers), it is not in general true that a package name corresponds 1:1
        /// with a plugin name. It replaces [](pulumirpc.LanguageRuntime.GetRequiredPlugins) in the face of [parameterized
        /// providers](parameterized-providers), which as mentioned above can enable multiple instances of the same plugin to
        /// provide multiple packages.
        pub async fn get_required_packages(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRequiredPackagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRequiredPackagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GetRequiredPackages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.LanguageRuntime", "GetRequiredPackages"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// `Run` executes a Pulumi program, returning information about whether or not the program produced an error.
        pub async fn run(
            &mut self,
            request: impl tonic::IntoRequest<super::RunRequest>,
        ) -> std::result::Result<tonic::Response<super::RunResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/Run",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "Run"));
            self.inner.unary(req, path, codec).await
        }
        /// `GetPluginInfo` returns information about the [plugin](plugins) implementing this language runtime.
        pub async fn get_plugin_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GetPluginInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "GetPluginInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// `InstallDependencies` accepts a request specifying a Pulumi project and program that can be executed with
        /// [](pulumirpc.LanguageRuntime.Run) and installs the dependencies for that program (e.g. by running `npm install`
        /// for NodeJS, or `pip install` for Python). Since dependency installation could take a while, and callers may wish
        /// to report on its progress, this method returns a stream of [](pulumirpc.InstallDependenciesResponse) messages
        /// containing information about standard error and output.
        pub async fn install_dependencies(
            &mut self,
            request: impl tonic::IntoRequest<super::InstallDependenciesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::InstallDependenciesResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/InstallDependencies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.LanguageRuntime", "InstallDependencies"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// `RuntimeOptionsPrompts` accepts a request specifying a Pulumi project and returns a list of additional prompts to
        /// ask during `pulumi new`.
        pub async fn runtime_options_prompts(
            &mut self,
            request: impl tonic::IntoRequest<super::RuntimeOptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeOptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/RuntimeOptionsPrompts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.LanguageRuntime", "RuntimeOptionsPrompts"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// `Template` allows the language runtime to perform additional templating on a newly instantiated project template.
        /// For example the Python runtime might want to convert a requirements.txt into a pyproject.toml suitable for use
        /// with uv or poetry.
        pub async fn template(
            &mut self,
            request: impl tonic::IntoRequest<super::TemplateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TemplateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/Template",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "Template"));
            self.inner.unary(req, path, codec).await
        }
        /// `About` returns information about the language runtime being used.
        pub async fn about(
            &mut self,
            request: impl tonic::IntoRequest<super::AboutRequest>,
        ) -> std::result::Result<tonic::Response<super::AboutResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/About",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "About"));
            self.inner.unary(req, path, codec).await
        }
        /// `GetProgramDependencies` computes the set of language-level dependencies (e.g. NPM packages for NodeJS, or Maven
        /// libraries for Java) required by a program.
        pub async fn get_program_dependencies(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProgramDependenciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProgramDependenciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GetProgramDependencies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pulumirpc.LanguageRuntime",
                        "GetProgramDependencies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// `RunPlugin` is used to execute a program written in this host's language that implements a Pulumi
        /// [plugin](plugins). It is to plugins what [](pulumirpc.LanguageRuntime.Run) is to programs. Since a plugin is not
        /// expected to terminate until instructed/for a long time, this method returns a stream of
        /// [](pulumirpc.RunPluginResponse) messages containing information about standard error and output, as well as the
        /// exit code of the plugin when it does terminate.
        pub async fn run_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::RunPluginRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RunPluginResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/RunPlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "RunPlugin"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// `GenerateProgram` generates code in this host's language that implements the given [PCL](pcl) program. Unlike
        /// [](pulumirpc.LanguageRuntime.GenerateProject), this method *only* generates program code, and does not e.g.
        /// generate a `package.json` for a NodeJS project that details how to run that code.
        /// [](pulumirpc.LanguageRuntime.GenerateProject), this method underpins ["programgen"](programgen) and the main
        /// functionality powering `pulumi convert`.
        pub async fn generate_program(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GenerateProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "GenerateProgram"));
            self.inner.unary(req, path, codec).await
        }
        /// `GenerateProject` generates code in this host's language that implements the given [PCL](pcl) program and wraps
        /// it in some language-specific notion of a "project", where a project is a buildable or runnable artifact. In this
        /// sense, `GenerateProject`'s output is a superset of that of [](pulumirpc.LanguageRuntime.GenerateProgram). For
        /// instance, when generating a NodeJS project, this method might generate a corresponding `package.json` file, as
        /// well as the relevant NodeJS program code. Along with [](pulumirpc.LanguageRuntime.GenerateProgram), this method
        /// underpins ["programgen"](programgen) and the main functionality powering `pulumi convert`.
        pub async fn generate_project(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GenerateProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "GenerateProject"));
            self.inner.unary(req, path, codec).await
        }
        /// `GeneratePackage` generates code in this host's language that implements an [SDK](sdkgen) ("sdkgen") for the
        /// given Pulumi package, as specified by a [schema](schema).
        pub async fn generate_package(
            &mut self,
            request: impl tonic::IntoRequest<super::GeneratePackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GeneratePackageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/GeneratePackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "GeneratePackage"));
            self.inner.unary(req, path, codec).await
        }
        /// `Pack` accepts a request specifying a generated SDK package and packs it into a language-specific artifact. For
        /// instance, in the case of Java, it might produce a JAR file from a list of `.java` sources; in the case of NodeJS,
        /// a `.tgz` file might be produced from a list of `.js` sources; and so on. Presently, `Pack` is primarily used in
        /// [language conformance tests](language-conformance-tests), though it is intended to be used more widely in future
        /// to standardise e.g. provider publishing workflows.
        pub async fn pack(
            &mut self,
            request: impl tonic::IntoRequest<super::PackRequest>,
        ) -> std::result::Result<tonic::Response<super::PackResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/Pack",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "Pack"));
            self.inner.unary(req, path, codec).await
        }
        /// `Link` links local dependencies into a project (program or plugin). The dependencies can be binary artifacts such
        /// as wheel or tar.gz files, or source directories. `Link` will update the language specific project files, such as
        /// `package.json`, `pyproject.toml`, `go.mod`, etc, to include the dependency. `Link` returns instructions for the
        /// user on how to use the linked package in the project.
        pub async fn link(
            &mut self,
            request: impl tonic::IntoRequest<super::LinkRequest>,
        ) -> std::result::Result<tonic::Response<super::LinkResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/Link",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "Link"));
            self.inner.unary(req, path, codec).await
        }
        /// `Cancel` signals the language runtime to gracefully shut down and abort any ongoing operations.
        /// Operations aborted in this way will return an error.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.LanguageRuntime/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.LanguageRuntime", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod language_runtime_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LanguageRuntimeServer.
    #[async_trait]
    pub trait LanguageRuntime: std::marker::Send + std::marker::Sync + 'static {
        /// `Handshake` is the first call made by the engine to a language host. It is used to pass the engine's address to
        /// the language host so that it may establish its own connections back, and to establish protocol configuration that
        /// will be used to communicate between the two parties.
        async fn handshake(
            &self,
            request: tonic::Request<super::LanguageHandshakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LanguageHandshakeResponse>,
            tonic::Status,
        >;
        /// `GetRequiredPlugins` computes the complete set of anticipated [plugins](plugins) required by a Pulumi program.
        /// Among other things, it is intended to be used to pre-install plugins before running a program with
        /// [](pulumirpc.LanguageRuntime.Run), to avoid the need to install them on-demand in response to [resource
        /// registrations](resource-registration) sent back from the running program to the engine.
        ///
        /// :::{important}
        /// The use of `GetRequiredPlugins` is deprecated in favour of [](pulumirpc.LanguageRuntime.GetRequiredPackages),
        /// which returns more granular information about which plugins are required by which packages.
        /// :::
        async fn get_required_plugins(
            &self,
            request: tonic::Request<super::GetRequiredPluginsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRequiredPluginsResponse>,
            tonic::Status,
        >;
        /// `GetRequiredPackages` computes the complete set of anticipated [packages](pulumirpc.PackageDependency) required
        /// by a program. It is used to pre-install packages before running a program with [](pulumirpc.LanguageRuntime.Run),
        /// to avoid the need to install them on-demand in response to [resource registrations](resource-registration) sent
        /// back from the running program to the engine. Moreover, when importing resources into a stack, it is used to
        /// determine which plugins are required to service the import of a given resource, since given the presence of
        /// [parameterized providers](parameterized-providers), it is not in general true that a package name corresponds 1:1
        /// with a plugin name. It replaces [](pulumirpc.LanguageRuntime.GetRequiredPlugins) in the face of [parameterized
        /// providers](parameterized-providers), which as mentioned above can enable multiple instances of the same plugin to
        /// provide multiple packages.
        async fn get_required_packages(
            &self,
            request: tonic::Request<super::GetRequiredPackagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRequiredPackagesResponse>,
            tonic::Status,
        >;
        /// `Run` executes a Pulumi program, returning information about whether or not the program produced an error.
        async fn run(
            &self,
            request: tonic::Request<super::RunRequest>,
        ) -> std::result::Result<tonic::Response<super::RunResponse>, tonic::Status>;
        /// `GetPluginInfo` returns information about the [plugin](plugins) implementing this language runtime.
        async fn get_plugin_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status>;
        /// Server streaming response type for the InstallDependencies method.
        type InstallDependenciesStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::InstallDependenciesResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// `InstallDependencies` accepts a request specifying a Pulumi project and program that can be executed with
        /// [](pulumirpc.LanguageRuntime.Run) and installs the dependencies for that program (e.g. by running `npm install`
        /// for NodeJS, or `pip install` for Python). Since dependency installation could take a while, and callers may wish
        /// to report on its progress, this method returns a stream of [](pulumirpc.InstallDependenciesResponse) messages
        /// containing information about standard error and output.
        async fn install_dependencies(
            &self,
            request: tonic::Request<super::InstallDependenciesRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::InstallDependenciesStream>,
            tonic::Status,
        >;
        /// `RuntimeOptionsPrompts` accepts a request specifying a Pulumi project and returns a list of additional prompts to
        /// ask during `pulumi new`.
        async fn runtime_options_prompts(
            &self,
            request: tonic::Request<super::RuntimeOptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeOptionsResponse>,
            tonic::Status,
        >;
        /// `Template` allows the language runtime to perform additional templating on a newly instantiated project template.
        /// For example the Python runtime might want to convert a requirements.txt into a pyproject.toml suitable for use
        /// with uv or poetry.
        async fn template(
            &self,
            request: tonic::Request<super::TemplateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TemplateResponse>,
            tonic::Status,
        >;
        /// `About` returns information about the language runtime being used.
        async fn about(
            &self,
            request: tonic::Request<super::AboutRequest>,
        ) -> std::result::Result<tonic::Response<super::AboutResponse>, tonic::Status>;
        /// `GetProgramDependencies` computes the set of language-level dependencies (e.g. NPM packages for NodeJS, or Maven
        /// libraries for Java) required by a program.
        async fn get_program_dependencies(
            &self,
            request: tonic::Request<super::GetProgramDependenciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProgramDependenciesResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the RunPlugin method.
        type RunPluginStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::RunPluginResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// `RunPlugin` is used to execute a program written in this host's language that implements a Pulumi
        /// [plugin](plugins). It is to plugins what [](pulumirpc.LanguageRuntime.Run) is to programs. Since a plugin is not
        /// expected to terminate until instructed/for a long time, this method returns a stream of
        /// [](pulumirpc.RunPluginResponse) messages containing information about standard error and output, as well as the
        /// exit code of the plugin when it does terminate.
        async fn run_plugin(
            &self,
            request: tonic::Request<super::RunPluginRequest>,
        ) -> std::result::Result<tonic::Response<Self::RunPluginStream>, tonic::Status>;
        /// `GenerateProgram` generates code in this host's language that implements the given [PCL](pcl) program. Unlike
        /// [](pulumirpc.LanguageRuntime.GenerateProject), this method *only* generates program code, and does not e.g.
        /// generate a `package.json` for a NodeJS project that details how to run that code.
        /// [](pulumirpc.LanguageRuntime.GenerateProject), this method underpins ["programgen"](programgen) and the main
        /// functionality powering `pulumi convert`.
        async fn generate_program(
            &self,
            request: tonic::Request<super::GenerateProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateProgramResponse>,
            tonic::Status,
        >;
        /// `GenerateProject` generates code in this host's language that implements the given [PCL](pcl) program and wraps
        /// it in some language-specific notion of a "project", where a project is a buildable or runnable artifact. In this
        /// sense, `GenerateProject`'s output is a superset of that of [](pulumirpc.LanguageRuntime.GenerateProgram). For
        /// instance, when generating a NodeJS project, this method might generate a corresponding `package.json` file, as
        /// well as the relevant NodeJS program code. Along with [](pulumirpc.LanguageRuntime.GenerateProgram), this method
        /// underpins ["programgen"](programgen) and the main functionality powering `pulumi convert`.
        async fn generate_project(
            &self,
            request: tonic::Request<super::GenerateProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateProjectResponse>,
            tonic::Status,
        >;
        /// `GeneratePackage` generates code in this host's language that implements an [SDK](sdkgen) ("sdkgen") for the
        /// given Pulumi package, as specified by a [schema](schema).
        async fn generate_package(
            &self,
            request: tonic::Request<super::GeneratePackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GeneratePackageResponse>,
            tonic::Status,
        >;
        /// `Pack` accepts a request specifying a generated SDK package and packs it into a language-specific artifact. For
        /// instance, in the case of Java, it might produce a JAR file from a list of `.java` sources; in the case of NodeJS,
        /// a `.tgz` file might be produced from a list of `.js` sources; and so on. Presently, `Pack` is primarily used in
        /// [language conformance tests](language-conformance-tests), though it is intended to be used more widely in future
        /// to standardise e.g. provider publishing workflows.
        async fn pack(
            &self,
            request: tonic::Request<super::PackRequest>,
        ) -> std::result::Result<tonic::Response<super::PackResponse>, tonic::Status>;
        /// `Link` links local dependencies into a project (program or plugin). The dependencies can be binary artifacts such
        /// as wheel or tar.gz files, or source directories. `Link` will update the language specific project files, such as
        /// `package.json`, `pyproject.toml`, `go.mod`, etc, to include the dependency. `Link` returns instructions for the
        /// user on how to use the linked package in the project.
        async fn link(
            &self,
            request: tonic::Request<super::LinkRequest>,
        ) -> std::result::Result<tonic::Response<super::LinkResponse>, tonic::Status>;
        /// `Cancel` signals the language runtime to gracefully shut down and abort any ongoing operations.
        /// Operations aborted in this way will return an error.
        async fn cancel(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    /// The LanguageRuntime service defines a standard interface for [language hosts/runtimes](languages). At a high level, a
    /// language runtime provides the ability to execute programs, install and query dependencies, and generate code for a
    /// specific language.
    #[derive(Debug)]
    pub struct LanguageRuntimeServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LanguageRuntimeServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LanguageRuntimeServer<T>
    where
        T: LanguageRuntime,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.LanguageRuntime/Handshake" => {
                    #[allow(non_camel_case_types)]
                    struct HandshakeSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::LanguageHandshakeRequest>
                    for HandshakeSvc<T> {
                        type Response = super::LanguageHandshakeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LanguageHandshakeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::handshake(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HandshakeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GetRequiredPlugins" => {
                    #[allow(non_camel_case_types)]
                    struct GetRequiredPluginsSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::GetRequiredPluginsRequest>
                    for GetRequiredPluginsSvc<T> {
                        type Response = super::GetRequiredPluginsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRequiredPluginsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::get_required_plugins(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRequiredPluginsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GetRequiredPackages" => {
                    #[allow(non_camel_case_types)]
                    struct GetRequiredPackagesSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::GetRequiredPackagesRequest>
                    for GetRequiredPackagesSvc<T> {
                        type Response = super::GetRequiredPackagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRequiredPackagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::get_required_packages(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRequiredPackagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/Run" => {
                    #[allow(non_camel_case_types)]
                    struct RunSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::RunRequest> for RunSvc<T> {
                        type Response = super::RunResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::run(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RunSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GetPluginInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetPluginInfoSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<T: LanguageRuntime> tonic::server::UnaryService<()>
                    for GetPluginInfoSvc<T> {
                        type Response = super::PluginInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::get_plugin_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPluginInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/InstallDependencies" => {
                    #[allow(non_camel_case_types)]
                    struct InstallDependenciesSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::ServerStreamingService<
                        super::InstallDependenciesRequest,
                    > for InstallDependenciesSvc<T> {
                        type Response = super::InstallDependenciesResponse;
                        type ResponseStream = T::InstallDependenciesStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InstallDependenciesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::install_dependencies(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InstallDependenciesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/RuntimeOptionsPrompts" => {
                    #[allow(non_camel_case_types)]
                    struct RuntimeOptionsPromptsSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::RuntimeOptionsRequest>
                    for RuntimeOptionsPromptsSvc<T> {
                        type Response = super::RuntimeOptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RuntimeOptionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::runtime_options_prompts(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RuntimeOptionsPromptsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/Template" => {
                    #[allow(non_camel_case_types)]
                    struct TemplateSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::TemplateRequest>
                    for TemplateSvc<T> {
                        type Response = super::TemplateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TemplateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::template(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TemplateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/About" => {
                    #[allow(non_camel_case_types)]
                    struct AboutSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::AboutRequest> for AboutSvc<T> {
                        type Response = super::AboutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AboutRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::about(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AboutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GetProgramDependencies" => {
                    #[allow(non_camel_case_types)]
                    struct GetProgramDependenciesSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::GetProgramDependenciesRequest>
                    for GetProgramDependenciesSvc<T> {
                        type Response = super::GetProgramDependenciesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProgramDependenciesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::get_program_dependencies(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetProgramDependenciesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/RunPlugin" => {
                    #[allow(non_camel_case_types)]
                    struct RunPluginSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::ServerStreamingService<super::RunPluginRequest>
                    for RunPluginSvc<T> {
                        type Response = super::RunPluginResponse;
                        type ResponseStream = T::RunPluginStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RunPluginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::run_plugin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RunPluginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GenerateProgram" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateProgramSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::GenerateProgramRequest>
                    for GenerateProgramSvc<T> {
                        type Response = super::GenerateProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::generate_program(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GenerateProject" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateProjectSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::GenerateProjectRequest>
                    for GenerateProjectSvc<T> {
                        type Response = super::GenerateProjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateProjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::generate_project(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateProjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/GeneratePackage" => {
                    #[allow(non_camel_case_types)]
                    struct GeneratePackageSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::GeneratePackageRequest>
                    for GeneratePackageSvc<T> {
                        type Response = super::GeneratePackageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GeneratePackageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::generate_package(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GeneratePackageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/Pack" => {
                    #[allow(non_camel_case_types)]
                    struct PackSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::PackRequest> for PackSvc<T> {
                        type Response = super::PackResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PackRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::pack(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/Link" => {
                    #[allow(non_camel_case_types)]
                    struct LinkSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<
                        T: LanguageRuntime,
                    > tonic::server::UnaryService<super::LinkRequest> for LinkSvc<T> {
                        type Response = super::LinkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::link(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.LanguageRuntime/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: LanguageRuntime>(pub Arc<T>);
                    impl<T: LanguageRuntime> tonic::server::UnaryService<()>
                    for CancelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LanguageRuntime>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LanguageRuntimeServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.LanguageRuntime";
    impl<T> tonic::server::NamedService for LanguageRuntimeServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alias {
    #[prost(oneof = "alias::Alias", tags = "1, 2")]
    pub alias: ::core::option::Option<alias::Alias>,
}
/// Nested message and enum types in `Alias`.
pub mod alias {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Spec {
        /// The previous name of the resource.  If none is provided, we will use the current name.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The previous type of the resource. If none is provided, we will use the current resoource type.
        #[prost(string, tag = "2")]
        pub r#type: ::prost::alloc::string::String,
        /// The previous stack of the resource. If not set, the current stack of the resource is used.
        #[prost(string, tag = "3")]
        pub stack: ::prost::alloc::string::String,
        /// The previous project of the resource. If not set, the current project of the resource is used.
        #[prost(string, tag = "4")]
        pub project: ::prost::alloc::string::String,
        /// The previous parent of the resource. If not set, the current parent of the resource is used.
        #[prost(oneof = "spec::Parent", tags = "5, 6")]
        pub parent: ::core::option::Option<spec::Parent>,
    }
    /// Nested message and enum types in `Spec`.
    pub mod spec {
        /// The previous parent of the resource. If not set, the current parent of the resource is used.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Parent {
            /// The urn of the previous parent.
            #[prost(string, tag = "5")]
            ParentUrn(::prost::alloc::string::String),
            /// Used to indicate the resource previously had no parent. If false this property is ignored.
            #[prost(bool, tag = "6")]
            NoParent(bool),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Alias {
        /// The previous urn to alias to.
        #[prost(string, tag = "1")]
        Urn(::prost::alloc::string::String),
        /// An alias specification.
        #[prost(message, tag = "2")]
        Spec(Spec),
    }
}
/// `ProviderHandshakeRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Handshake) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProviderHandshakeRequest {
    /// The gRPC address of the engine handshaking with the provider. At a minimum, this address will expose an instance
    /// of the [](pulumirpc.Engine) service.
    #[prost(string, tag = "1")]
    pub engine_address: ::prost::alloc::string::String,
    /// A *root directory* where the provider's binary, `PulumiPlugin.yaml`, or other identifying source code is located.
    /// In the event that the provider is *not* being booted by the engine (e.g. in the case that the engine has been
    /// asked to attach to an existing running provider instance via a host/port number), this field will be empty.
    #[prost(string, optional, tag = "2")]
    pub root_directory: ::core::option::Option<::prost::alloc::string::String>,
    /// A *program directory* in which the provider should execute. This is generally a subdirectory of the root
    /// directory, though this is not required. In the event that the provider is *not* being booted by the engine (e.g.
    /// in the case that the engine has been asked to attach to an existing running provider instance via a host/port
    /// number), this field will be empty.
    #[prost(string, optional, tag = "3")]
    pub program_directory: ::core::option::Option<::prost::alloc::string::String>,
    /// If true the engine will send URN, Name, Type, and ID to the provider as part of the configuration.
    #[prost(bool, tag = "4")]
    pub configure_with_urn: bool,
    /// If true the engine supports views and can send the address of a [](pulumirpc.ResourceStatus) service which can be
    /// used to e.g. create or update view resources.
    #[prost(bool, tag = "5")]
    pub supports_views: bool,
    /// If true the engine supports letting the provider mark resource states as requiring refresh before update.
    #[prost(bool, tag = "6")]
    pub supports_refresh_before_update: bool,
    /// If true the engine will send `preview` to `Invoke` methods to let them know if the current operation is a preview or up.
    #[prost(bool, tag = "7")]
    pub invoke_with_preview: bool,
}
/// `ProviderHandshakeResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Handshake) call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProviderHandshakeResponse {
    /// True if and only if the provider supports secrets. If true, the caller should pass secrets as strongly typed
    /// values to the provider. *Must* match the value returned in response to [](pulumirpc.ResourceProvider.Configure).
    #[prost(bool, tag = "1")]
    pub accept_secrets: bool,
    /// True if and only if the provider supports strongly typed resources. If true, the caller should pass resources as
    /// strongly typed values to the provider. *Must* match the value returned in response to
    /// [](pulumirpc.ResourceProvider.Configure).
    #[prost(bool, tag = "2")]
    pub accept_resources: bool,
    /// True if and only if the provider supports output values as inputs. If true, the engine should pass output values
    /// to the provider where possible. *Must* match the value returned in response to
    /// [](pulumirpc.ResourceProvider.Configure).
    #[prost(bool, tag = "3")]
    pub accept_outputs: bool,
    /// True if the provider accepts and respects autonaming configuration that the engine provides on behalf of the
    /// user. *Must* match the value returned in response to [](pulumirpc.ResourceProvider.Configure).
    #[prost(bool, tag = "4")]
    pub supports_autonaming_configuration: bool,
}
/// `ParameterizeRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Parameterize) call. A
/// `ParameterizeRequest` may contain either:
///
/// * a string array (`ParametersArgs`), intended to represent a set of command-line arguments so as to support
///    instantiating a parameterized provider from a command-line invocation (e.g. to generate an SDK).
/// * a byte array accompanied by a name and version (`ParametersValue`), intended to represent a parameter embedded in a
///    previously generated SDK.
///
/// Embedding parameter values in SDKs allows programs to consume parameterized providers without needing to know the
/// details of the parameterization. Allowing the representation embedded into an SDK to differ from that supplied on the
/// command-line permits providers to implement optimizations for the common, fast-path case (program execution), such as
/// embedding a generated schema as opposed to generating it on-demand for each resource registration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterizeRequest {
    #[prost(oneof = "parameterize_request::Parameters", tags = "1, 2")]
    pub parameters: ::core::option::Option<parameterize_request::Parameters>,
}
/// Nested message and enum types in `ParameterizeRequest`.
pub mod parameterize_request {
    /// A parameter value, represented as an array of strings, as might be provided by a command-line invocation, such as
    /// that used to generate an SDK.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParametersArgs {
        #[prost(string, repeated, tag = "1")]
        pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A parameter value, represented by an arbitrary array of bytes accompanied by a name and version. This is expected
    /// to be the format used by parameterized provider SDKs.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParametersValue {
        /// The sub-package name for this sub-schema parameterization.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The sub-package version for this sub-schema parameterization.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        /// The embedded value from the sub-package.
        #[prost(bytes = "vec", tag = "3")]
        pub value: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Parameters {
        /// Arguments from the command line.
        #[prost(message, tag = "1")]
        Args(ParametersArgs),
        /// Values from a generated SDK.
        #[prost(message, tag = "2")]
        Value(ParametersValue),
    }
}
/// `ParameterizeResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Parameterize) call. It
/// contains a name and version that can be used to identify the sub-package that now exists as a result of
/// parameterization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterizeResponse {
    /// The name of the sub-package parameterized.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the sub-package parameterized.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRequest {
    /// the schema version.
    #[prost(int32, tag = "1")]
    pub version: i32,
    /// the name of the sub-package to lookup
    #[prost(string, tag = "2")]
    pub subpackage_name: ::prost::alloc::string::String,
    /// the version of the sub-package to lookup
    #[prost(string, tag = "3")]
    pub subpackage_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaResponse {
    /// the JSON-encoded schema.
    #[prost(string, tag = "1")]
    pub schema: ::prost::alloc::string::String,
}
/// `ConfigureRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Configure) call. Requests
/// include both provider-specific inputs (`variables` or `args`) and provider-agnostic ("protocol") configuration
/// (`acceptSecrets`, `acceptResources`, and so on).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureRequest {
    /// :::{warning}
    /// `variables` is deprecated; `args` should be used instead wherever possible.
    /// :::
    ///
    /// A map of input properties for the provider. Compound values, such as nested objects, should be JSON encoded so
    /// that they too can be passed as strings. For instance, the following configuration:
    ///
    /// ```
    /// {
    ///    "a": 42,
    ///    "b": {
    ///      "c": "hello",
    ///      "d": true
    ///    }
    /// }
    /// ```
    ///
    /// should be encoded as:
    ///
    /// ```
    /// {
    ///    "a": "42",
    ///    "b": "{\"c\":\"hello\",\"d\":true}"
    /// }
    /// ```
    #[prost(map = "string, string", tag = "1")]
    pub variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A map of input properties for the provider.
    ///
    /// :::{warning}
    /// `args` may include secrets. Because `ConfigureRequest` is sent before [](pulumirpc.ConfigureResponse) can specify
    /// whether or not the provider accepts secrets in general, providers *must* handle secrets if they appear in `args`.
    /// :::
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// True if and only if the caller supports secrets. If true, operations should return strongly typed secrets if the
    /// provider supports them also. *Must* be true if the caller has previously called
    /// [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "3")]
    pub accept_secrets: bool,
    /// True if and only if the caller supports strongly typed resources. If true, operations should return resources as
    /// strongly typed values if the provider supports them also. *Must* be true if the caller has previously called
    /// [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "4")]
    pub accept_resources: bool,
    /// True if and only if the caller supports sending old inputs as part of [](pulumirpc.ResourceProvider.Diff) and
    /// [](pulumirpc.ResourceProvider.Update) calls. If true, the provider should expect these fields to be populated in
    /// these calls. *Must* be true if the caller has previously called [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "5")]
    pub sends_old_inputs: bool,
    /// True if and only if the caller supports sending old inputs and outputs as part of
    /// [](pulumirpc.ResourceProvider.Delete) calls. If true, the provider should expect these fields to be populated in
    /// these calls. *Must* be true if the caller has previously called [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "6")]
    pub sends_old_inputs_to_delete: bool,
    /// The ID of the provider being configured. N.B. This will be null if configure_with_urn was false in
    /// Handshake.
    #[prost(string, optional, tag = "7")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// The URN of the provider being configured. N.B. This will be null if configure_with_urn was false in
    /// Handshake.
    #[prost(string, optional, tag = "8")]
    pub urn: ::core::option::Option<::prost::alloc::string::String>,
    /// The name of the provider being configured. This must match the name specified by the `urn` field, and
    /// is passed so that providers do not have to implement URN parsing in order to extract the name of the
    /// provider.  N.B. This will be null if configure_with_urn was false in Handshake.
    #[prost(string, optional, tag = "9")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The type of the provider being configured. This must match the type specified by the `urn` field, and
    /// is passed so that providers do not have to implement URN parsing in order to extract the type of the
    /// provider. N.B. This will be null if configure_with_urn was false in Handshake.
    #[prost(string, optional, tag = "10")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// `ConfigureResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Configure) call. Its primary
/// purpose is to communicate features that the provider supports back to the caller.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigureResponse {
    /// True if and only if the provider supports secrets. If true, the caller should pass secrets as strongly typed
    /// values to the provider. *Must* match the value returned in response to [](pulumirpc.ResourceProvider.Handshake)
    /// if the provider supports handshaking.
    #[prost(bool, tag = "1")]
    pub accept_secrets: bool,
    /// True if and only if the provider supports the `preview` field on [](pulumirpc.ResourceProvider.Create) and
    /// [](pulumirpc.ResourceProvider.Update) calls. If true, the engine should invoke these calls with `preview` set to
    /// `true` during previews. *Must* be true if the provider implements [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "2")]
    pub supports_preview: bool,
    /// True if and only if the provider supports strongly typed resources. If true, the caller should pass resources as
    /// strongly typed values to the provider. *Must* match the value returned in response to
    /// [](pulumirpc.ResourceProvider.Handshake) if the provider supports handshaking.
    #[prost(bool, tag = "3")]
    pub accept_resources: bool,
    /// True if and only if the provider supports output values as inputs. If true, the engine should pass output values
    /// to the provider where possible. *Must* match the value returned in response to
    /// [](pulumirpc.ResourceProvider.Handshake) if the provider supports handshaking.
    #[prost(bool, tag = "4")]
    pub accept_outputs: bool,
    /// True if the provider accepts and respects autonaming configuration that the engine provides on behalf of the
    /// user. *Must* match the value returned in response to [](pulumirpc.ResourceProvider.Handshake) if the provider
    /// supports handshaking.
    #[prost(bool, tag = "5")]
    pub supports_autonaming_configuration: bool,
}
/// `ConfigureErrorMissingKeys` is the type of error details that may be sent in response to a
/// [](pulumirpc.ResourceProvider.Configure) call when required configuration keys are missing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureErrorMissingKeys {
    /// A list of required configuration keys that were not supplied.
    #[prost(message, repeated, tag = "1")]
    pub missing_keys: ::prost::alloc::vec::Vec<configure_error_missing_keys::MissingKey>,
}
/// Nested message and enum types in `ConfigureErrorMissingKeys`.
pub mod configure_error_missing_keys {
    /// The type of key-value pairs representing keys that are missing from a [](pulumirpc.ResourceProvider.Configure)
    /// call.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MissingKey {
        /// The name of the missing configuration key.
        ///
        /// :::{note}
        /// This should be the *Pulumi name* of the missing key, and not any provider-internal or upstream name. Names
        /// that differ between Pulumi and an upstream provider should be translated prior to being returned.
        /// :::
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// A description of the missing config key, as reported by the provider.
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// This is only set if `HandshakeRequest.invoke_with_preview` was true. If this is true then the engine is currently
    /// running a preview deployment.
    #[prost(bool, tag = "7")]
    pub preview: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeResponse {
    /// the returned values, if invoke was successful.
    #[prost(message, optional, tag = "1")]
    pub r#return: ::core::option::Option<::prost_types::Struct>,
    /// the failures if any arguments didn't pass verification.
    #[prost(message, repeated, tag = "2")]
    pub failures: ::prost::alloc::vec::Vec<CheckFailure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// a map from argument keys to the dependencies of the argument.
    #[prost(map = "string, message", tag = "3")]
    pub arg_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        call_request::ArgumentDependencies,
    >,
    /// the project name.
    #[prost(string, tag = "6")]
    pub project: ::prost::alloc::string::String,
    /// the name of the stack being deployed into.
    #[prost(string, tag = "7")]
    pub stack: ::prost::alloc::string::String,
    /// the configuration variables to apply before running.
    #[prost(map = "string, string", tag = "8")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// the configuration keys that have secret values.
    #[prost(string, repeated, tag = "9")]
    pub config_secret_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// true if we're only doing a dryrun (preview).
    #[prost(bool, tag = "10")]
    pub dry_run: bool,
    /// the degree of parallelism for resource operations (<=1 for serial).
    #[prost(int32, tag = "11")]
    pub parallel: i32,
    /// the address for communicating back to the resource monitor.
    #[prost(string, tag = "12")]
    pub monitor_endpoint: ::prost::alloc::string::String,
    /// the organization of the stack being deployed into.
    #[prost(string, tag = "14")]
    pub organization: ::prost::alloc::string::String,
    /// the engine can be passed output values back, returnDependencies can be left blank if returning output values.
    #[prost(bool, tag = "17")]
    pub accepts_output_values: bool,
    /// The stack trace handle for the call. Supports stitching stack traces together across plugins.
    #[prost(string, tag = "18")]
    pub stack_trace_handle: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CallRequest`.
pub mod call_request {
    /// ArgumentDependencies describes the resources that a particular argument depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArgumentDependencies {
        /// A list of URNs this argument depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallResponse {
    /// the returned values, if call was successful.
    #[prost(message, optional, tag = "1")]
    pub r#return: ::core::option::Option<::prost_types::Struct>,
    /// the failures if any arguments didn't pass verification.
    #[prost(message, repeated, tag = "3")]
    pub failures: ::prost::alloc::vec::Vec<CheckFailure>,
    /// a map from return value keys to the dependencies of the return value.
    ///
    /// returnDependencies will be augmented by the set of dependencies specified in return
    /// via output property values.
    #[prost(map = "string, message", tag = "2")]
    pub return_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        call_response::ReturnDependencies,
    >,
}
/// Nested message and enum types in `CallResponse`.
pub mod call_response {
    /// ReturnDependencies describes the resources that a particular return value depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReturnDependencies {
        /// A list of URNs this return value depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// `CheckRequest` is the type of requests sent as part of [](pulumirpc.ResourceProvider.CheckConfig) and
/// [](pulumirpc.ResourceProvider.Check) calls. A `CheckRequest` primarily captures the URN and inputs of the resource
/// being checked. In the case of [](pulumirpc.ResourceProvider.CheckConfig), the URN will be the URN of the provider
/// resource being constructed, which may or may not be a [default provider](default-providers), and the inputs will be
/// the provider configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckRequest {
    /// The URN of the resource whose inputs are being checked. In the case of
    /// [](pulumirpc.ResourceProvider.CheckConfig), this will be the URN of the provider resource being constructed,
    /// which may or may not be a [default provider](default-providers).
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// The old input properties or configuration for the resource, if any.
    #[prost(message, optional, tag = "2")]
    pub olds: ::core::option::Option<::prost_types::Struct>,
    /// The new input properties or configuration for the resource, if any.
    ///
    /// :::{note}
    /// If this resource has been specified with the
    /// [`ignoreChanges`](<https://www.pulumi.com/docs/concepts/options/ignorechanges/>), then the values in `news` may
    /// differ from those written in the Pulumi program registering this resource. In such cases, the caller (e.g. the
    /// Pulumi engine) is expected to preprocess the `news` value by replacing every property matched by `ignoreChanges`
    /// with its corresponding `olds` value (effectively ignoring the change).
    /// :::
    #[prost(message, optional, tag = "3")]
    pub news: ::core::option::Option<::prost_types::Struct>,
    /// A random but deterministically computed hash, intended to be used for generating globally unique names.
    #[prost(bytes = "vec", tag = "5")]
    pub random_seed: ::prost::alloc::vec::Vec<u8>,
    /// The name of the resource being checked. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being checked. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub autonaming: ::core::option::Option<check_request::AutonamingOptions>,
}
/// Nested message and enum types in `CheckRequest`.
pub mod check_request {
    /// Configuration for automatic resource naming behavior. This structure contains fields that control how the provider
    /// handles resource names, including proposed names and naming modes.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AutonamingOptions {
        /// The proposed name for the resource being checked. This may be used by the provider as a suggestion
        /// for the final resource name, depending on the specified mode.
        #[prost(string, tag = "1")]
        pub proposed_name: ::prost::alloc::string::String,
        #[prost(enumeration = "autonaming_options::Mode", tag = "2")]
        pub mode: i32,
    }
    /// Nested message and enum types in `AutonamingOptions`.
    pub mod autonaming_options {
        /// The mode that controls how the provider handles the proposed name. If not specified, defaults to `PROPOSE`.
        /// - `PROPOSE`: The provider may use the proposed name as a suggestion but is free to modify it.
        /// - `ENFORCE`: The provider must use exactly the proposed name or return an error.
        /// - `DISABLE`: The provider should disable automatic naming and return an error if no explicit name
        ///    is provided by user's program.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Propose = 0,
            Enforce = 1,
            Disable = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Propose => "PROPOSE",
                    Self::Enforce => "ENFORCE",
                    Self::Disable => "DISABLE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PROPOSE" => Some(Self::Propose),
                    "ENFORCE" => Some(Self::Enforce),
                    "DISABLE" => Some(Self::Disable),
                    _ => None,
                }
            }
        }
    }
}
/// `CheckResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.CheckConfig) or
/// [](pulumirpc.ResourceProvider.Check) call. A `CheckResponse` may contain either:
///
/// * a set of checked, known-valid `inputs`. In the case of [](pulumirpc.ResourceProvider.CheckConfig), these may
///    subsequently be passed to [](pulumirpc.ResourceProvider.DiffConfig) and/or
///    [](pulumirpc.ResourceProvider.Configure). In the case of [](pulumirpc.ResourceProvider.Check), these may be passed
///    to any of the supported lifecycle methods that accept provider inputs.
/// * a set of `failures` detailing invalid inputs.
///
/// In cases where the supplied set of inputs is valid, a `CheckResponse` may contain default values that should
/// persisted to Pulumi state and passed to subsequent calls.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckResponse {
    /// A valid, checked set of inputs. May contain defaults.
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// Any validation failures that occurred.
    #[prost(message, repeated, tag = "2")]
    pub failures: ::prost::alloc::vec::Vec<CheckFailure>,
}
/// A `CheckFailure` describes a single validation error that arose as part of a
/// [](pulumirpc.ResourceProvider.CheckConfig) or [](pulumirpc.ResourceProvider.Check) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckFailure {
    /// The input property that failed validation.
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    /// The reason that the named property failed validation.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// `DiffRequest` is the type of requests sent as part of [](pulumirpc.ResourceProvider.DiffConfig) and
/// [](pulumirpc.ResourceProvider.Diff) calls. A `DiffRequest` primarily captures:
///
/// * the URN of the resource whose properties are being compared;
/// * the old and new input properties of the resource; and
/// * the old output properties of the resource.
///
/// In the case of [](pulumirpc.ResourceProvider.DiffConfig), the URN will be the URN of the provider resource being
/// examined, which may or may not be a [default provider](default-providers), and the inputs and outputs will be the
/// provider configuration and state. Inputs supplied to a [](pulumirpc.ResourceProvider.DiffConfig) call should have
/// been previously checked by a call to [](pulumirpc.ResourceProvider.CheckConfig); inputs supplied to a
/// [](pulumirpc.ResourceProvider.Diff) call should have been previously checked by a call to
/// [](pulumirpc.ResourceProvider.Check).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiffRequest {
    /// The ID of the resource being diffed.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource being diffed.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// The old *output* properties of the resource being diffed.
    #[prost(message, optional, tag = "3")]
    pub olds: ::core::option::Option<::prost_types::Struct>,
    /// The new *input* properties of the resource being diffed. These should have been validated by an appropriate call
    /// to [](pulumirpc.ResourceProvider.CheckConfig) or [](pulumirpc.ResourceProvider.Check).
    #[prost(message, optional, tag = "4")]
    pub news: ::core::option::Option<::prost_types::Struct>,
    /// A set of [property paths](property-paths) that should be treated as unchanged.
    #[prost(string, repeated, tag = "5")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The old *input* properties of the resource being diffed.
    #[prost(message, optional, tag = "6")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being diffed. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being diffed. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "8")]
    pub r#type: ::prost::alloc::string::String,
}
/// `PropertyDiff` describes the kind of change that occurred to a property during a diff operation. A `PropertyDiff` may
/// indicate that a property was added, deleted, or updated, and may further indicate that the change requires a
/// replacement.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PropertyDiff {
    /// The kind of diff associated with this property.
    #[prost(enumeration = "property_diff::Kind", tag = "1")]
    pub kind: i32,
    /// True if and only if this difference represents one between a pair of old and new inputs, as opposed to a pair of
    /// old and new states.
    #[prost(bool, tag = "2")]
    pub input_diff: bool,
}
/// Nested message and enum types in `PropertyDiff`.
pub mod property_diff {
    /// The type of property diff kinds.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        /// This property was added.
        Add = 0,
        /// This property was added, and this change requires a replace.
        AddReplace = 1,
        /// This property was removed.
        Delete = 2,
        /// This property was removed, and this change requires a replace.
        DeleteReplace = 3,
        /// This property's value was changed.
        Update = 4,
        /// This property's value was changed, and this change requires a replace.
        UpdateReplace = 5,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Add => "ADD",
                Self::AddReplace => "ADD_REPLACE",
                Self::Delete => "DELETE",
                Self::DeleteReplace => "DELETE_REPLACE",
                Self::Update => "UPDATE",
                Self::UpdateReplace => "UPDATE_REPLACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADD" => Some(Self::Add),
                "ADD_REPLACE" => Some(Self::AddReplace),
                "DELETE" => Some(Self::Delete),
                "DELETE_REPLACE" => Some(Self::DeleteReplace),
                "UPDATE" => Some(Self::Update),
                "UPDATE_REPLACE" => Some(Self::UpdateReplace),
                _ => None,
            }
        }
    }
}
/// `DiffResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.DiffConfig) or
/// [](pulumirpc.ResourceProvider.Diff) call. A `DiffResponse` indicates whether a resource is unchanged, requires
/// updating (that is, can be changed "in place"), or requires replacement (that is, must be destroyed and recreated
/// anew). Legacy implementations may also signal that it is unknown whether there are changes or not.
///
/// `DiffResponse` has evolved since its inception and there are now a number of ways that providers can signal their
/// intent to callers:
///
/// * *Simple diffs* utilise the `changes` field to signal which fields are responsible for a change, and the `replaces`
///    field to further communicate which changes (if any) require a replacement as opposed to an update.
///
/// * *Detailed diffs* are those with `hasDetailedDiff` set, and utilise the `detailedDiff` field to provide a more
///    granular view of the changes that have occurred. Detailed diffs are designed to allow providers to control
///    precisely which field names are displayed as responsible for a change, and to signal more accurately what kind of
///    change occurred (e.g. a field was added, deleted or updated).
///
/// The response must satisfy the following invariants:
///
/// * For each top-level key in `diff` there is at least one matching property path, starting at that key, in `detailedDiff`.
/// * For each entry in `detailedDiff`, its top-level property is in `diff`.
/// * `diff` does not contain duplicates.
/// * `detailedDiff` does not contain duplicate keys.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiffResponse {
    /// A set of properties which have changed and whose changes require the resource being diffed to be replaced. The
    /// caller should replace the resource if this set is non-empty, or if any of the properties specified in
    /// `detailedDiff` have a `*_REPLACE` kind.
    #[prost(string, repeated, tag = "1")]
    pub replaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// An optional list of properties that will not ever change (are stable).
    #[prost(string, repeated, tag = "2")]
    pub stables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, this resource must be deleted *before* its replacement is created.
    #[prost(bool, tag = "3")]
    pub delete_before_replace: bool,
    /// The result of the diff. Indicates at a high level whether the resource has changed or not (or, in legacy cases,
    /// if the provider does not know).
    #[prost(enumeration = "diff_response::DiffChanges", tag = "4")]
    pub changes: i32,
    /// The set of properties which have changed. This field only supports top-level properties. It *does not* support
    /// full [property paths](property-paths); implementations should use `detailedDiff` when this is required.
    #[prost(string, repeated, tag = "5")]
    pub diffs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// `detailedDiff` can be used to implement more detailed diffs. A detailed diff is a map from [property
    /// paths](property-paths) to [](pulumirpc.PropertyDiff)s, which describe the kind of change that occurred to the
    /// property located at that path. If a provider does not implement this, the caller (typically the Pulumi engine)
    /// will compute a representation based on the simple diff fields (`changes`, `replaces`, and so on).
    #[prost(map = "string, message", tag = "6")]
    pub detailed_diff: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PropertyDiff,
    >,
    /// True if and only if this response contains a `detailedDiff`.
    #[prost(bool, tag = "7")]
    pub has_detailed_diff: bool,
}
/// Nested message and enum types in `DiffResponse`.
pub mod diff_response {
    /// The type of high-level diff results.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiffChanges {
        /// A diff was performed but it is unknown whether there are changes or not. This exists to support legacy
        /// behaviour and should be generally avoided wherever possible.
        DiffUnknown = 0,
        /// A diff was performed and there were no changes. An update is not required.
        DiffNone = 1,
        /// A diff was performed, and changes were detected that require an update or replacement.
        DiffSome = 2,
    }
    impl DiffChanges {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DiffUnknown => "DIFF_UNKNOWN",
                Self::DiffNone => "DIFF_NONE",
                Self::DiffSome => "DIFF_SOME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIFF_UNKNOWN" => Some(Self::DiffUnknown),
                "DIFF_NONE" => Some(Self::DiffNone),
                "DIFF_SOME" => Some(Self::DiffSome),
                _ => None,
            }
        }
    }
}
/// `CreateRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Create) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRequest {
    /// The URN of the resource being created.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// The resource's input properties, to be set during creation. These should have been validated by a call to
    /// [](pulumirpc.ResourceProvider.Check).
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// A timeout in seconds that the caller is prepared to wait for the operation to complete.
    #[prost(double, tag = "3")]
    pub timeout: f64,
    /// True if and only if the request is being made as part of a preview/dry run, in which case the provider should not
    /// actually create the resource.
    #[prost(bool, tag = "4")]
    pub preview: bool,
    /// The name of the resource being created. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being created. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
    /// The address of a [](pulumirpc.ResourceStatus) service which can be used to e.g. create or update view resources.
    #[prost(string, tag = "7")]
    pub resource_status_address: ::prost::alloc::string::String,
    /// The [](pulumirpc.ResourceStatus) service context token to pass when calling methods on the service.
    #[prost(string, tag = "8")]
    pub resource_status_token: ::prost::alloc::string::String,
}
/// `CreateResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Create) call. A `CreateResponse`
/// contains the ID of the created resource, as well as any output properties that arose from the creation process.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResponse {
    /// The ID of the created resource.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The resource's output properties. Typically this will be a union of the resource's input properties and any
    /// additional values that were computed or made available during creation.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Indicates that this resource should always be refreshed prior to updates.
    #[prost(bool, tag = "3")]
    pub refresh_before_update: bool,
}
/// `ReadRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Read) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    /// The ID of the resource to read.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource being read.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// Any current state for the resource being read. This state should be sufficient to uniquely identify the resource.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Any current input properties for the resource being read. These will only be populated when the
    /// [](pulumirpc.ResourceProvider.Read) call is being made as part of a refresh operation.
    #[prost(message, optional, tag = "4")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being read. This must match the name specified by the `urn` field, and is passed so that
    /// providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being read. This must match the type specified by the `urn` field, and is passed so that
    /// providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
    /// The address of a [](pulumirpc.ResourceStatus) service which can be used to e.g. create or update view resources.
    #[prost(string, tag = "7")]
    pub resource_status_address: ::prost::alloc::string::String,
    /// The [](pulumirpc.ResourceStatus) service context token to pass when calling methods on the service.
    #[prost(string, tag = "8")]
    pub resource_status_token: ::prost::alloc::string::String,
    /// The old views for the resource being read. These will only be populated when the
    /// [](pulumirpc.ResourceProvider.Read) call is being made as part of a refresh operation.
    #[prost(message, repeated, tag = "9")]
    pub old_views: ::prost::alloc::vec::Vec<View>,
}
/// `ReadResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Read) call. A `ReadResponse` contains
/// the ID of the resource being read, as well as any state that was successfully read from the live environment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    /// The ID of the read resource.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The output properties of the resource read from the live environment.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Output-derived input properties for the resource. These are returned as they would be returned from a
    /// [](pulumirpc.ResourceProvider.Check) call with the same values.
    #[prost(message, optional, tag = "3")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// Indicates that this resource should always be refreshed prior to updates.
    #[prost(bool, tag = "4")]
    pub refresh_before_update: bool,
}
/// `UpdateRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Update) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRequest {
    /// The ID of the resource being updated.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource being updated.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// The old *output* properties of the resource being updated.
    #[prost(message, optional, tag = "3")]
    pub olds: ::core::option::Option<::prost_types::Struct>,
    /// The new input properties of the resource being updated. These should have been validated by a call to
    /// [](pulumirpc.ResourceProvider.Check).
    #[prost(message, optional, tag = "4")]
    pub news: ::core::option::Option<::prost_types::Struct>,
    /// A timeout in seconds that the caller is prepared to wait for the operation to complete.
    #[prost(double, tag = "5")]
    pub timeout: f64,
    /// A set of [property paths](property-paths) that should be treated as unchanged.
    #[prost(string, repeated, tag = "6")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// True if and only if the request is being made as part of a preview/dry run, in which case the provider should not
    /// actually update the resource.
    #[prost(bool, tag = "7")]
    pub preview: bool,
    /// The old *input* properties of the resource being updated.
    #[prost(message, optional, tag = "8")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being updated. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "9")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being updated. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "10")]
    pub r#type: ::prost::alloc::string::String,
    /// The address of a [](pulumirpc.ResourceStatus) service which can be used to e.g. create or update view resources.
    #[prost(string, tag = "11")]
    pub resource_status_address: ::prost::alloc::string::String,
    /// The [](pulumirpc.ResourceStatus) service context token to pass when calling methods on the service.
    #[prost(string, tag = "12")]
    pub resource_status_token: ::prost::alloc::string::String,
    /// The old views for the resource being updated.
    #[prost(message, repeated, tag = "13")]
    pub old_views: ::prost::alloc::vec::Vec<View>,
}
/// `UpdateResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Update) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResponse {
    /// An updated set of resource output properties. Typically this will be a union of the resource's inputs and any
    /// additional values that were computed or made available during the update.
    #[prost(message, optional, tag = "1")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Indicates that this resource should always be refreshed prior to updates.
    #[prost(bool, tag = "2")]
    pub refresh_before_update: bool,
}
/// `DeleteRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Delete) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    /// The ID of the resource to delete.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource to delete.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// The old *output* properties of the resource being deleted.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// A timeout in seconds that the caller is prepared to wait for the operation to complete.
    #[prost(double, tag = "4")]
    pub timeout: f64,
    /// The old *input* properties of the resource being deleted.
    ///
    /// the old input values of the resource to delete.
    #[prost(message, optional, tag = "5")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being deleted. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being deleted. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
    /// The address of a [](pulumirpc.ResourceStatus) service which can be used to e.g. create or update view resources.
    #[prost(string, tag = "8")]
    pub resource_status_address: ::prost::alloc::string::String,
    /// The [](pulumirpc.ResourceStatus) service context token to pass when calling methods on the service.
    #[prost(string, tag = "9")]
    pub resource_status_token: ::prost::alloc::string::String,
    /// The old views for the resource being read.
    #[prost(message, repeated, tag = "10")]
    pub old_views: ::prost::alloc::vec::Vec<View>,
}
/// `ConstructRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Construct) call. A
/// `ConstructRequest` captures enough data to be able to register nested components against the caller's resource
/// monitor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstructRequest {
    /// The project to which this resource and its nested resources will belong.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// The name of the stack being deployed into.
    #[prost(string, tag = "2")]
    pub stack: ::prost::alloc::string::String,
    /// Configuration for the specified project and stack.
    #[prost(map = "string, string", tag = "3")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// True if and only if the request is being made as part of a preview/dry run, in which case the provider should not
    /// actually construct the component.
    #[prost(bool, tag = "4")]
    pub dry_run: bool,
    /// The degree of parallelism that may be used for resource operations. A value less than or equal to 1 indicates
    /// that operations should be performed serially.
    #[prost(int32, tag = "5")]
    pub parallel: i32,
    /// The address of the [](pulumirpc.ResourceMonitor) that the provider should connect to in order to send [resource
    /// registrations](resource-registration) for its nested resources.
    #[prost(string, tag = "6")]
    pub monitor_endpoint: ::prost::alloc::string::String,
    /// The type of the component resource being constructed. This must match the type specified by the `urn` field, and
    /// is passed so that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
    /// The name of the component resource being constructed. This must match the name specified by the `urn` field, and
    /// is passed so that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "8")]
    pub name: ::prost::alloc::string::String,
    /// An optional parent resource that the component (and by extension, its nested resources) should be children of.
    #[prost(string, tag = "9")]
    pub parent: ::prost::alloc::string::String,
    /// The component resource's input properties. Unlike the inputs of custom resources, these will *not* have been
    /// passed to a call to [](pulumirpc.ResourceProvider.Check). By virtue of their being a composition of other
    /// resources, component resources are able to (and therefore expected) to validate their own inputs. Moreover,
    /// [](pulumirpc.ResourceProvider.Check) will be called on any inputs passed to nested custom resources as usual.
    #[prost(message, optional, tag = "10")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// A map of property dependencies for the component resource and its nested resources.
    #[prost(map = "string, message", tag = "11")]
    pub input_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        construct_request::PropertyDependencies,
    >,
    /// A map of package names to provider references for the component resource and its nested resources.
    #[prost(map = "string, string", tag = "13")]
    pub providers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A list of URNs that this resource and its nested resources depend on.
    #[prost(string, repeated, tag = "15")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A set of configuration keys whose values are [secret](output-secrets).
    #[prost(string, repeated, tag = "16")]
    pub config_secret_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The organization to which this resource and its nested resources will belong.
    #[prost(string, tag = "17")]
    pub organization: ::prost::alloc::string::String,
    /// True if and only if the resource (and by extension, its nested resources) should be marked as protected.
    /// Protected resources cannot be deleted without first being unprotected.
    #[prost(bool, optional, tag = "12")]
    pub protect: ::core::option::Option<bool>,
    /// A list of input properties whose values should be treated as [secret](output-secrets).
    #[prost(string, repeated, tag = "18")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// A set of custom timeouts that specify how long the caller is prepared to wait for the various CRUD operations of
    /// this resource's nested resources.
    #[prost(message, optional, tag = "19")]
    pub custom_timeouts: ::core::option::Option<construct_request::CustomTimeouts>,
    /// The URN of a resource that this resource (and thus its nested resources) will be implicitly deleted with. If the
    /// resource referred to by this URN is deleted in the same operation that this resource would be deleted, the
    /// [](pulumirpc.ResourceProvider.Delete) call for this resource will be elided (since this dependency signals that
    /// it will have already been deleted).
    #[prost(string, tag = "20")]
    pub deleted_with: ::prost::alloc::string::String,
    /// If true, this resource (and its nested resources) must be deleted *before* its replacement is created.
    #[prost(bool, optional, tag = "21")]
    pub delete_before_replace: ::core::option::Option<bool>,
    /// A set of [property paths](property-paths) that should be treated as unchanged.
    #[prost(string, repeated, tag = "22")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A set of properties that, when changed, trigger a replacement.
    #[prost(string, repeated, tag = "23")]
    pub replace_on_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// True if [](pulumirpc.ResourceProvider.Delete) should *not* be called when the resource (and by extension, its
    /// nested resources) are removed from a Pulumi program.
    #[prost(bool, optional, tag = "24")]
    pub retain_on_delete: ::core::option::Option<bool>,
    /// True if the caller is capable of accepting output values in response to the call. If this is set, these outputs
    /// may be used to communicate dependency information and so there is no need to populate
    /// [](pulumirpc.ConstructResponse)'s `stateDependencies` field.
    #[prost(bool, tag = "25")]
    pub accepts_output_values: bool,
    #[prost(message, optional, tag = "26")]
    pub resource_hooks: ::core::option::Option<construct_request::ResourceHooksBinding>,
    /// The stack trace handle for the construct call. Supports stitching stack traces together across plugins.
    #[prost(string, tag = "27")]
    pub stack_trace_handle: ::prost::alloc::string::String,
    /// The URNs of resources whose replaces will trigger a replace on this resource.
    #[prost(string, repeated, tag = "28")]
    pub replace_with: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// a list of additional aliases that should be considered the same.
    #[prost(message, repeated, tag = "29")]
    pub aliases: ::prost::alloc::vec::Vec<Alias>,
    /// If set, the engine will diff this value with the last recorded value, and trigger a replace if they are not
    /// equal.
    #[prost(message, optional, tag = "30")]
    pub replacement_trigger: ::core::option::Option<::prost_types::Value>,
}
/// Nested message and enum types in `ConstructRequest`.
pub mod construct_request {
    /// A `PropertyDependencies` list is a set of URNs that a particular property may depend on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs that this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A `CustomTimeouts` object encapsulates a set of timeouts for the various CRUD operations that might be performed
    /// on this resource's nested resources. Timeout values are specified as duration strings, such as `"5ms"` (5
    /// milliseconds), `"40s"` (40 seconds), or `"1m30s"` (1 minute and 30 seconds). The following units of time are
    /// supported:
    ///
    /// * `ns`: nanoseconds
    /// * `us` or `s`: microseconds
    /// * `ms`: milliseconds
    /// * `s`: seconds
    /// * `m`: minutes
    /// * `h`: hours
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomTimeouts {
        /// How long a caller is prepared to wait for a nested resource's [](pulumirpc.ResourceProvider.Create) operation
        /// to complete.
        #[prost(string, tag = "1")]
        pub create: ::prost::alloc::string::String,
        /// How long a caller is prepared to wait for a nested resource's [](pulumirpc.ResourceProvider.Update) operation
        /// to complete.
        #[prost(string, tag = "2")]
        pub update: ::prost::alloc::string::String,
        /// How long a caller is prepared to wait for a nested resource's [](pulumirpc.ResourceProvider.Delete) operation
        /// to complete.
        #[prost(string, tag = "3")]
        pub delete: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceHooksBinding {
        #[prost(string, repeated, tag = "1")]
        pub before_create: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub after_create: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub before_update: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub after_update: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "5")]
        pub before_delete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "6")]
        pub after_delete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "7")]
        pub on_error: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// `ConstructResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Construct) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstructResponse {
    /// The URN of the constructed component resource.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// Any output properties that the component registered as part of its construction.
    #[prost(message, optional, tag = "2")]
    pub state: ::core::option::Option<::prost_types::Struct>,
    /// A map of property dependencies for the component's outputs. This will be set if the caller indicated that it
    /// could not receive dependency-communicating [output](outputs) values by setting [](pulumirpc.ConstructRequest)'s
    /// `accepts_output_values` field to false.
    #[prost(map = "string, message", tag = "3")]
    pub state_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        construct_response::PropertyDependencies,
    >,
}
/// Nested message and enum types in `ConstructResponse`.
pub mod construct_response {
    /// A `PropertyDependencies` list is a set of URNs that a particular property may depend on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs that this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// ErrorResourceInitFailed is sent as a Detail `ResourceProvider.{Create, Update}` fail because a
/// resource was created successfully, but failed to initialize.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResourceInitFailed {
    /// the ID of the created resource.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// any properties that were computed during updating.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// error messages associated with initialization failure.
    #[prost(string, repeated, tag = "3")]
    pub reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the current inputs to this resource (only applicable for Read)
    #[prost(message, optional, tag = "4")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// Indicates that this resource should always be refreshed prior to updates.
    #[prost(bool, tag = "5")]
    pub refresh_before_update: bool,
}
/// `GetMappingRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.GetMapping) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingRequest {
    /// The conversion key for the mapping being requested. This typically corresponds to the source language, such as
    /// `terraform` in the case of mapping Terraform names to Pulumi names.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// An optional *source provider key* for the mapping being requested. If this is empty, the provider should assume
    /// that this request is from an old engine prior to the introduction of [](pulumirpc.ResourceProvider.GetMappings).
    /// In these cases the request should be answered with the "primary" mapping. If this field is set, the `provider`
    /// field in the corresponding [](pulumirpc.GetMappingResponse) should contain the same value.
    #[prost(string, tag = "2")]
    pub provider: ::prost::alloc::string::String,
}
/// `GetMappingResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.GetMapping) call. The data
/// within a `GetMappingResponse` will normally be human-readable JSON (e.g. an object mapping names from the source to
/// Pulumi), but the engine doesn't mandate any specific format.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingResponse {
    /// The *source provider key* that this mapping contains data for.
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
    /// Mapping data in a format specific to the conversion plugin/source language.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// `GetMappingsRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.GetMappings) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingsRequest {
    /// The conversion key for the mapping being requested. This typically corresponds to the source language, such as
    /// `terraform` in the case of mapping Terraform names to Pulumi names.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
/// `GetMappingsResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.GetMappings) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingsResponse {
    /// The set of *source provider keys* this provider can supply mappings for. For example the Pulumi provider
    /// `terraform-template` would return `\["template"\]` for this.
    #[prost(string, repeated, tag = "1")]
    pub providers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// `View` represents the state of a view resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct View {
    /// The type of the view resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// The name of the view resource.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// An optional type of the parent view resource.
    #[prost(string, tag = "3")]
    pub parent_type: ::prost::alloc::string::String,
    /// An optional name of the parent view resource.
    #[prost(string, tag = "4")]
    pub parent_name: ::prost::alloc::string::String,
    /// The view resource's inputs.
    #[prost(message, optional, tag = "5")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// The view resource's outputs.
    #[prost(message, optional, tag = "6")]
    pub outputs: ::core::option::Option<::prost_types::Struct>,
}
/// Generated client implementations.
pub mod resource_provider_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ResourceProvider service defines a standard interface for [resource providers](providers). A resource provider
    /// manages a set of configuration, resources, functions and so on in a single package, and offers methods such as CRUD
    /// operations on resources and invocations of functions. Resource providers are primarily managed by the Pulumi engine
    /// as part of a deployment in order to interact with the cloud providers underpinning a Pulumi application.
    #[derive(Debug, Clone)]
    pub struct ResourceProviderClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ResourceProviderClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ResourceProviderClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResourceProviderClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ResourceProviderClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// `Handshake` is the first call made by the engine to a provider. It is used to pass the engine's address to the
        /// provider so that it may establish its own connections back, and to establish protocol configuration that will be
        /// used to communicate between the two parties. Providers that support `Handshake` should return responses
        /// consistent with those returned in response to [](pulumirpc.ResourceProvider.Configure) calls where there is
        /// overlap due to the use of `Configure` prior to `Handshake`'s introduction.
        pub async fn handshake(
            &mut self,
            request: impl tonic::IntoRequest<super::ProviderHandshakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProviderHandshakeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Handshake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Handshake"));
            self.inner.unary(req, path, codec).await
        }
        /// `Parameterize` is the primary means of supporting [parameterized providers](parameterized-providers), which allow
        /// a caller to change a provider's behavior ahead of its [configuration](pulumirpc.ResourceProvider.Configure) and
        /// subsequent use. Where a [](pulumirpc.ResourceProvider.Configure) call allows a caller to influence provider
        /// behaviour at a high level (e.g. by specifying the region in which an AWS provider should operate), a
        /// `Parameterize` call may change the set of resources and functions that a provider offers (that is, its schema).
        /// This is useful in any case where some "set" of providers can be captured by a single implementation that may
        /// power fundamentally different schemata -- dynamically bridging Terraform providers, or managing Kubernetes
        /// clusters with custom resource definitions, for instance, are good examples. The parameterized package that
        /// `Parameterize` yields is known as a *sub-package* of the original (unparameterized) package.
        ///
        /// `Parameterize` supports two types of parameterization:
        ///
        /// * *Replacement parameterization*, whereby a `Parameterize` call results in a schema that completely replaces the
        ///   original provider schema. Bridging a Terraform provider dynamically might be an example of this -- following
        ///   the call to `Parameterize`, the provider's schema will become that of the Terraform provider that was bridged.
        ///   Providers that implement replacement parameterization expect a *single* call to `Parameterize`.
        ///
        /// * *Extension parameterization*, in which a `Parameterize` call results in a schema that is a superset of the
        ///   original. This is useful in cases where a provider can be extended with additional resources or functions, such
        ///   as a Kubernetes provider that can be extended with resources representing custom resource definitions.
        ///   Providers that implement extension parameterization should accept multiple calls to `Parameterize`. Extension
        ///   packages may even be called multiple times with the same package name, but with different versions. The CRUD
        ///   operations of extension resources must include the version of which sub-package they correspond to.
        ///
        /// `Parameterize` should work the same whether it is provided with `ParametersArgs` or `ParametersValue` input. In
        /// each case it should return the sub-package name and version (which when a `ParametersValue` is supplied should
        /// match the given input).
        pub async fn parameterize(
            &mut self,
            request: impl tonic::IntoRequest<super::ParameterizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ParameterizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Parameterize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Parameterize"));
            self.inner.unary(req, path, codec).await
        }
        /// GetSchema fetches the schema for this resource provider.
        pub async fn get_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSchemaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/GetSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetSchema"));
            self.inner.unary(req, path, codec).await
        }
        /// `CheckConfig` validates a set of configuration inputs that will be passed to this provider instance.
        /// `CheckConfig` is to provider resources what [](pulumirpc.ResourceProvider.Check) is to individual resources, and
        /// is the first stage in configuring (that is, eventually executing a [](pulumirpc.ResourceProvider.Configure) call)
        /// a provider using user-supplied values. In the case that provider inputs are coming from some source that has been
        /// checked previously (e.g. a Pulumi state), it is not necessary to call `CheckConfig`.
        ///
        /// A `CheckConfig` call returns either a set of checked, known-valid inputs that may subsequently be passed to
        /// [](pulumirpc.ResourceProvider.DiffConfig) and/or [](pulumirpc.ResourceProvider.Configure), or a set of errors
        /// explaining why the inputs are invalid. In the case that a set of inputs are successfully validated and returned,
        /// `CheckConfig` *may also populate default values* for provider configuration, returning them so that they may be
        /// passed to a subsequent [](pulumirpc.ResourceProvider.Configure) call and persisted in the Pulumi state. In the
        /// case that `CheckConfig` fails and returns a set of errors, it is expected that the caller (typically the Pulumi
        /// engine) will fail provider registration.
        ///
        /// As a rule, the provider inputs returned by a call to `CheckConfig` should preserve the original representation of
        /// the properties as present in the program inputs. Though this rule is not required for correctness, violations
        /// thereof can negatively impact the end-user experience, as the provider inputs are used for detecting and
        /// rendering diffs.
        pub async fn check_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/CheckConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "CheckConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// `DiffConfig` compares an existing ("old") provider configuration with a new configuration and computes the
        /// difference (if any) between them. `DiffConfig` is to provider resources what [](pulumirpc.ResourceProvider.Diff)
        /// is to individual resources. `DiffConfig` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.CheckConfig) call. The [](pulumirpc.DiffResponse) returned by a `DiffConfig`
        /// call is used primarily to determine whether or not the newly configured provider is capable of managing resources
        /// owned by the old provider. If `DiffConfig` indicates that the provider resource needs to be replaced, for
        /// instance, then all resources owned by that provider will *also* need to be replaced. Replacement semantics should
        /// thus be reserved for changes to configuration properties that are guaranteed to make old resources unmanageable.
        /// Changes to an AWS region, for example, will almost certainly require a provider replacement, but changes to an
        /// AWS access key, should almost certainly not.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        pub async fn diff_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/DiffConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "DiffConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// `Configure` is the final stage in configuring a provider instance. Callers may supply two sets of data:
        ///
        /// * Provider-specific configuration, which is the set of inputs that have been validated by a previous
        ///   [](pulumirpc.ResourceProvider.CheckConfig) call.
        /// * Provider-agnostic ("protocol") configuration, such as whether or not the caller supports secrets.
        ///
        /// The provider is expected to return its own set of protocol configuration, indicating which features it supports
        /// in turn so that the caller and the provider can interact appropriately.
        ///
        /// Providers may expect a *single* call to `Configure`. If a call to `Configure` is missing required configuration,
        /// the provider may return a set of error details containing [](pulumirpc.ConfigureErrorMissingKeys) values to
        /// indicate which keys are missing.
        ///
        /// :::{important}
        /// The use of `Configure` to configure protocol features is deprecated in favour of the
        /// [](pulumirpc.ResourceProvider.Handshake) method, which should be implemented by newer providers. To enable
        /// compatibility between older engines and providers:
        ///
        /// * Callers which call `Handshake` *must* call `Configure` with flags such as `acceptSecrets` and `acceptResources`
        ///   set to `true`, since these features predate the introduction of `Handshake` and thus `Handshake`-aware callers
        ///   must support them. See [](pulumirpc.ConfigureRequest) for more information.
        /// * Providers which implement `Handshake` *must* support flags such as `acceptSecrets` and `acceptResources`, and
        ///   indicate as such by always returning `true` for these fields in [](pulumirpc.ConfigureResponse). See
        ///   [](pulumirpc.ConfigureResponse) for more information.
        /// :::
        pub async fn configure(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfigureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfigureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Configure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Configure"));
            self.inner.unary(req, path, codec).await
        }
        /// Invoke dynamically executes a built-in function in the provider.
        pub async fn invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Invoke",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Invoke"));
            self.inner.unary(req, path, codec).await
        }
        /// Call dynamically executes a method in the provider associated with a component resource.
        pub async fn call(
            &mut self,
            request: impl tonic::IntoRequest<super::CallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Call",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Call"));
            self.inner.unary(req, path, codec).await
        }
        /// `Check` validates a set of input properties against a given resource type. A `Check` call returns either a set of
        /// checked, known-valid inputs that may subsequently be passed to [](pulumirpc.ResourceProvider.Diff),
        /// [](pulumirpc.ResourceProvider.Create), or [](pulumirpc.ResourceProvider.Update); or a set of errors explaining
        /// why the inputs are invalid. In the case that a set of inputs are successfully validated and returned, `Check`
        /// *may also populate default values* for resource inputs, returning them so that they may be passed to a subsequent
        /// call and persisted in the Pulumi state. In the case that `Check` fails and returns a set of errors, it is
        /// expected that the caller (typically the Pulumi engine) will fail resource registration.
        ///
        /// As a rule, the provider inputs returned by a call to `Check` should preserve the original representation of the
        /// properties as present in the program inputs. Though this rule is not required for correctness, violations thereof
        /// can negatively impact the end-user experience, as the provider inputs are used for detecting and rendering
        /// diffs.
        pub async fn check(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Check",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Check"));
            self.inner.unary(req, path, codec).await
        }
        /// `Diff` compares an existing ("old") set of resource properties with a new set of properties and computes the
        /// difference (if any) between them. `Diff` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.Check) call.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        pub async fn diff(
            &mut self,
            request: impl tonic::IntoRequest<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Diff",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Diff"));
            self.inner.unary(req, path, codec).await
        }
        /// `Create` provisions a new instance of the specified [(custom) resource](custom-resources). It returns a
        /// provider-assigned ID for the resource as well as the output properties that arose from the creation properties.
        /// Output properties are typically the union of the resource's input properties and any additional values that were
        /// computed or made available during creation.
        ///
        /// If creation fails, `Create` may return an [](pulumirpc.ErrorResourceInitFailed) error detail explaining why.
        /// Moreover, if `Create` does return an error, it must be the case that the resource was *not* created (that is,
        /// `Create` can be thought of as transactional or atomic).
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Create",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Create"));
            self.inner.unary(req, path, codec).await
        }
        /// `Read` reads the current live state associated with a resource identified by the supplied state. The given state
        /// must be sufficient to uniquely identify the resource. This is typically just the resource ID, but may also
        /// include other properties.
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Read",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Read"));
            self.inner.unary(req, path, codec).await
        }
        /// `Update` updates an existing resource according to a new set of inputs, returning a new set of output properties.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Update"));
            self.inner.unary(req, path, codec).await
        }
        /// `Delete` deprovisions an existing resource as specified by its ID. `Delete` should be transactional/atomic -- if
        /// a call to `Delete` fails, it must be the case that the resource was *not* deleted and can be assumed to still
        /// exist.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// `Construct` provisions a new [component resource](component-resources). Providers that implement `Construct` are
        /// referred to as [component providers](component-providers). `Construct` is to component resources what
        /// [](pulumirpc.ResourceProvider.Create) is to [custom resources](custom-resources). Components do not have any
        /// lifecycle of their own, and instead embody the lifecycles of the resources that they are composed of. As such,
        /// `Construct` is effectively a subprogram whose resources will be persisted in the caller's state. It is
        /// consequently passed enough information to manage fully these resources. At a high level, this comprises:
        ///
        /// * A [](pulumirpc.ResourceMonitor) endpoint which the provider can use to [register](resource-registration) nested
        ///   custom or component resources that belong to the component.
        ///
        /// * A set of input properties.
        ///
        /// * A full set of [resource options](https://www.pulumi.com/docs/iac/concepts/options/) that the component should
        ///   propagate to resources it registers against the supplied resource monitor.
        pub async fn construct(
            &mut self,
            request: impl tonic::IntoRequest<super::ConstructRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConstructResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Construct",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Construct"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel signals the provider to gracefully shut down and abort any ongoing resource operations.
        /// Operations aborted in this way will return an error (e.g., `Update` and `Create` will either return a
        /// creation error or an initialization error). Since Cancel is advisory and non-blocking, it is up
        /// to the host to decide how long to wait after Cancel is called before (e.g.)
        /// hard-closing any gRPC connection.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
        /// GetPluginInfo returns generic information about this plugin, like its version.
        pub async fn get_plugin_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/GetPluginInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetPluginInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Attach sends the engine address to an already running plugin.
        pub async fn attach(
            &mut self,
            request: impl tonic::IntoRequest<super::PluginAttach>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/Attach",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Attach"));
            self.inner.unary(req, path, codec).await
        }
        /// `GetMapping` returns mappings designed to aid in [converting programs and state from other
        /// ecosystems](converters). It accepts a "conversion key", which effectively corresponds to a source language, such
        /// as `terraform`, and a *source provider name*, which is the name of the provider *in the source language*. Given
        /// these, it returns source-specific mapping data for the provider requested. As an example, the Pulumi AWS
        /// provider, which is bridged from the Terraform AWS provider and thus capable of mapping names between the two,
        /// might respond to a call with key `terraform` and source provider name `aws` with mapping data for transforming
        /// (among other things) Terraform AWS names such as `aws_s3_bucket` into Pulumi AWS types such as
        /// `aws:s3/bucket:Bucket`. If a provider only supports a single source provider, or has some sensible default, it
        /// may respond also to a call in which the source provider name is empty (`""`), which will be made when the engine
        /// does not have sufficient knowledge to work out which provider offers a specific mapping.
        ///
        /// In general, it is expected that providers implemented by bridging an equivalent provider from another ecosystem
        /// (such as bridged Terraform providers built atop the `pulumi-terraform-bridge`, for instance) implement
        /// `GetMapping` to support conversion from that ecosystem into Pulumi using the same logic that underpins the
        /// bridging itself.
        pub async fn get_mapping(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMappingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMappingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/GetMapping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetMapping"));
            self.inner.unary(req, path, codec).await
        }
        /// `GetMappings` is an optional method designed to aid in [converting programs and state from other
        /// ecosystems](converters). `GetMappings` accepts a "conversion key". This corresponds to a source language, for
        /// which we want to retrieve mappings for names etc. from that source language into Pulumi. An example key might
        /// therefore be `terraform` in the event that we wish to map e.g. Terraform resource names to Pulumi resource types.
        /// Given a key, `GetMappings` returns a list of *source provider names* for which calls to `GetMapping` will return
        /// mappings. So, continuing the Terraform example, the Pulumi AWS provider, which is bridged from the Terraform AWS
        /// provider and thus capable of mapping names between the two, might return the list `["aws"]` in response to a call
        /// with key `terraform`.
        ///
        /// If a provider does not implement `GetMappings`, the engine will fall back to calling `GetMapping` blindly without
        /// a source provider name (that is, with the value `""`).
        pub async fn get_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMappingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceProvider/GetMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetMappings"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod resource_provider_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ResourceProviderServer.
    #[async_trait]
    pub trait ResourceProvider: std::marker::Send + std::marker::Sync + 'static {
        /// `Handshake` is the first call made by the engine to a provider. It is used to pass the engine's address to the
        /// provider so that it may establish its own connections back, and to establish protocol configuration that will be
        /// used to communicate between the two parties. Providers that support `Handshake` should return responses
        /// consistent with those returned in response to [](pulumirpc.ResourceProvider.Configure) calls where there is
        /// overlap due to the use of `Configure` prior to `Handshake`'s introduction.
        async fn handshake(
            &self,
            request: tonic::Request<super::ProviderHandshakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProviderHandshakeResponse>,
            tonic::Status,
        >;
        /// `Parameterize` is the primary means of supporting [parameterized providers](parameterized-providers), which allow
        /// a caller to change a provider's behavior ahead of its [configuration](pulumirpc.ResourceProvider.Configure) and
        /// subsequent use. Where a [](pulumirpc.ResourceProvider.Configure) call allows a caller to influence provider
        /// behaviour at a high level (e.g. by specifying the region in which an AWS provider should operate), a
        /// `Parameterize` call may change the set of resources and functions that a provider offers (that is, its schema).
        /// This is useful in any case where some "set" of providers can be captured by a single implementation that may
        /// power fundamentally different schemata -- dynamically bridging Terraform providers, or managing Kubernetes
        /// clusters with custom resource definitions, for instance, are good examples. The parameterized package that
        /// `Parameterize` yields is known as a *sub-package* of the original (unparameterized) package.
        ///
        /// `Parameterize` supports two types of parameterization:
        ///
        /// * *Replacement parameterization*, whereby a `Parameterize` call results in a schema that completely replaces the
        ///   original provider schema. Bridging a Terraform provider dynamically might be an example of this -- following
        ///   the call to `Parameterize`, the provider's schema will become that of the Terraform provider that was bridged.
        ///   Providers that implement replacement parameterization expect a *single* call to `Parameterize`.
        ///
        /// * *Extension parameterization*, in which a `Parameterize` call results in a schema that is a superset of the
        ///   original. This is useful in cases where a provider can be extended with additional resources or functions, such
        ///   as a Kubernetes provider that can be extended with resources representing custom resource definitions.
        ///   Providers that implement extension parameterization should accept multiple calls to `Parameterize`. Extension
        ///   packages may even be called multiple times with the same package name, but with different versions. The CRUD
        ///   operations of extension resources must include the version of which sub-package they correspond to.
        ///
        /// `Parameterize` should work the same whether it is provided with `ParametersArgs` or `ParametersValue` input. In
        /// each case it should return the sub-package name and version (which when a `ParametersValue` is supplied should
        /// match the given input).
        async fn parameterize(
            &self,
            request: tonic::Request<super::ParameterizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ParameterizeResponse>,
            tonic::Status,
        >;
        /// GetSchema fetches the schema for this resource provider.
        async fn get_schema(
            &self,
            request: tonic::Request<super::GetSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSchemaResponse>,
            tonic::Status,
        >;
        /// `CheckConfig` validates a set of configuration inputs that will be passed to this provider instance.
        /// `CheckConfig` is to provider resources what [](pulumirpc.ResourceProvider.Check) is to individual resources, and
        /// is the first stage in configuring (that is, eventually executing a [](pulumirpc.ResourceProvider.Configure) call)
        /// a provider using user-supplied values. In the case that provider inputs are coming from some source that has been
        /// checked previously (e.g. a Pulumi state), it is not necessary to call `CheckConfig`.
        ///
        /// A `CheckConfig` call returns either a set of checked, known-valid inputs that may subsequently be passed to
        /// [](pulumirpc.ResourceProvider.DiffConfig) and/or [](pulumirpc.ResourceProvider.Configure), or a set of errors
        /// explaining why the inputs are invalid. In the case that a set of inputs are successfully validated and returned,
        /// `CheckConfig` *may also populate default values* for provider configuration, returning them so that they may be
        /// passed to a subsequent [](pulumirpc.ResourceProvider.Configure) call and persisted in the Pulumi state. In the
        /// case that `CheckConfig` fails and returns a set of errors, it is expected that the caller (typically the Pulumi
        /// engine) will fail provider registration.
        ///
        /// As a rule, the provider inputs returned by a call to `CheckConfig` should preserve the original representation of
        /// the properties as present in the program inputs. Though this rule is not required for correctness, violations
        /// thereof can negatively impact the end-user experience, as the provider inputs are used for detecting and
        /// rendering diffs.
        async fn check_config(
            &self,
            request: tonic::Request<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status>;
        /// `DiffConfig` compares an existing ("old") provider configuration with a new configuration and computes the
        /// difference (if any) between them. `DiffConfig` is to provider resources what [](pulumirpc.ResourceProvider.Diff)
        /// is to individual resources. `DiffConfig` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.CheckConfig) call. The [](pulumirpc.DiffResponse) returned by a `DiffConfig`
        /// call is used primarily to determine whether or not the newly configured provider is capable of managing resources
        /// owned by the old provider. If `DiffConfig` indicates that the provider resource needs to be replaced, for
        /// instance, then all resources owned by that provider will *also* need to be replaced. Replacement semantics should
        /// thus be reserved for changes to configuration properties that are guaranteed to make old resources unmanageable.
        /// Changes to an AWS region, for example, will almost certainly require a provider replacement, but changes to an
        /// AWS access key, should almost certainly not.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        async fn diff_config(
            &self,
            request: tonic::Request<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status>;
        /// `Configure` is the final stage in configuring a provider instance. Callers may supply two sets of data:
        ///
        /// * Provider-specific configuration, which is the set of inputs that have been validated by a previous
        ///   [](pulumirpc.ResourceProvider.CheckConfig) call.
        /// * Provider-agnostic ("protocol") configuration, such as whether or not the caller supports secrets.
        ///
        /// The provider is expected to return its own set of protocol configuration, indicating which features it supports
        /// in turn so that the caller and the provider can interact appropriately.
        ///
        /// Providers may expect a *single* call to `Configure`. If a call to `Configure` is missing required configuration,
        /// the provider may return a set of error details containing [](pulumirpc.ConfigureErrorMissingKeys) values to
        /// indicate which keys are missing.
        ///
        /// :::{important}
        /// The use of `Configure` to configure protocol features is deprecated in favour of the
        /// [](pulumirpc.ResourceProvider.Handshake) method, which should be implemented by newer providers. To enable
        /// compatibility between older engines and providers:
        ///
        /// * Callers which call `Handshake` *must* call `Configure` with flags such as `acceptSecrets` and `acceptResources`
        ///   set to `true`, since these features predate the introduction of `Handshake` and thus `Handshake`-aware callers
        ///   must support them. See [](pulumirpc.ConfigureRequest) for more information.
        /// * Providers which implement `Handshake` *must* support flags such as `acceptSecrets` and `acceptResources`, and
        ///   indicate as such by always returning `true` for these fields in [](pulumirpc.ConfigureResponse). See
        ///   [](pulumirpc.ConfigureResponse) for more information.
        /// :::
        async fn configure(
            &self,
            request: tonic::Request<super::ConfigureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfigureResponse>,
            tonic::Status,
        >;
        /// Invoke dynamically executes a built-in function in the provider.
        async fn invoke(
            &self,
            request: tonic::Request<super::InvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status>;
        /// Call dynamically executes a method in the provider associated with a component resource.
        async fn call(
            &self,
            request: tonic::Request<super::CallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status>;
        /// `Check` validates a set of input properties against a given resource type. A `Check` call returns either a set of
        /// checked, known-valid inputs that may subsequently be passed to [](pulumirpc.ResourceProvider.Diff),
        /// [](pulumirpc.ResourceProvider.Create), or [](pulumirpc.ResourceProvider.Update); or a set of errors explaining
        /// why the inputs are invalid. In the case that a set of inputs are successfully validated and returned, `Check`
        /// *may also populate default values* for resource inputs, returning them so that they may be passed to a subsequent
        /// call and persisted in the Pulumi state. In the case that `Check` fails and returns a set of errors, it is
        /// expected that the caller (typically the Pulumi engine) will fail resource registration.
        ///
        /// As a rule, the provider inputs returned by a call to `Check` should preserve the original representation of the
        /// properties as present in the program inputs. Though this rule is not required for correctness, violations thereof
        /// can negatively impact the end-user experience, as the provider inputs are used for detecting and rendering
        /// diffs.
        async fn check(
            &self,
            request: tonic::Request<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status>;
        /// `Diff` compares an existing ("old") set of resource properties with a new set of properties and computes the
        /// difference (if any) between them. `Diff` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.Check) call.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        async fn diff(
            &self,
            request: tonic::Request<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status>;
        /// `Create` provisions a new instance of the specified [(custom) resource](custom-resources). It returns a
        /// provider-assigned ID for the resource as well as the output properties that arose from the creation properties.
        /// Output properties are typically the union of the resource's input properties and any additional values that were
        /// computed or made available during creation.
        ///
        /// If creation fails, `Create` may return an [](pulumirpc.ErrorResourceInitFailed) error detail explaining why.
        /// Moreover, if `Create` does return an error, it must be the case that the resource was *not* created (that is,
        /// `Create` can be thought of as transactional or atomic).
        async fn create(
            &self,
            request: tonic::Request<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status>;
        /// `Read` reads the current live state associated with a resource identified by the supplied state. The given state
        /// must be sufficient to uniquely identify the resource. This is typically just the resource ID, but may also
        /// include other properties.
        async fn read(
            &self,
            request: tonic::Request<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status>;
        /// `Update` updates an existing resource according to a new set of inputs, returning a new set of output properties.
        async fn update(
            &self,
            request: tonic::Request<super::UpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateResponse>, tonic::Status>;
        /// `Delete` deprovisions an existing resource as specified by its ID. `Delete` should be transactional/atomic -- if
        /// a call to `Delete` fails, it must be the case that the resource was *not* deleted and can be assumed to still
        /// exist.
        async fn delete(
            &self,
            request: tonic::Request<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// `Construct` provisions a new [component resource](component-resources). Providers that implement `Construct` are
        /// referred to as [component providers](component-providers). `Construct` is to component resources what
        /// [](pulumirpc.ResourceProvider.Create) is to [custom resources](custom-resources). Components do not have any
        /// lifecycle of their own, and instead embody the lifecycles of the resources that they are composed of. As such,
        /// `Construct` is effectively a subprogram whose resources will be persisted in the caller's state. It is
        /// consequently passed enough information to manage fully these resources. At a high level, this comprises:
        ///
        /// * A [](pulumirpc.ResourceMonitor) endpoint which the provider can use to [register](resource-registration) nested
        ///   custom or component resources that belong to the component.
        ///
        /// * A set of input properties.
        ///
        /// * A full set of [resource options](https://www.pulumi.com/docs/iac/concepts/options/) that the component should
        ///   propagate to resources it registers against the supplied resource monitor.
        async fn construct(
            &self,
            request: tonic::Request<super::ConstructRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConstructResponse>,
            tonic::Status,
        >;
        /// Cancel signals the provider to gracefully shut down and abort any ongoing resource operations.
        /// Operations aborted in this way will return an error (e.g., `Update` and `Create` will either return a
        /// creation error or an initialization error). Since Cancel is advisory and non-blocking, it is up
        /// to the host to decide how long to wait after Cancel is called before (e.g.)
        /// hard-closing any gRPC connection.
        async fn cancel(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// GetPluginInfo returns generic information about this plugin, like its version.
        async fn get_plugin_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status>;
        /// Attach sends the engine address to an already running plugin.
        async fn attach(
            &self,
            request: tonic::Request<super::PluginAttach>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// `GetMapping` returns mappings designed to aid in [converting programs and state from other
        /// ecosystems](converters). It accepts a "conversion key", which effectively corresponds to a source language, such
        /// as `terraform`, and a *source provider name*, which is the name of the provider *in the source language*. Given
        /// these, it returns source-specific mapping data for the provider requested. As an example, the Pulumi AWS
        /// provider, which is bridged from the Terraform AWS provider and thus capable of mapping names between the two,
        /// might respond to a call with key `terraform` and source provider name `aws` with mapping data for transforming
        /// (among other things) Terraform AWS names such as `aws_s3_bucket` into Pulumi AWS types such as
        /// `aws:s3/bucket:Bucket`. If a provider only supports a single source provider, or has some sensible default, it
        /// may respond also to a call in which the source provider name is empty (`""`), which will be made when the engine
        /// does not have sufficient knowledge to work out which provider offers a specific mapping.
        ///
        /// In general, it is expected that providers implemented by bridging an equivalent provider from another ecosystem
        /// (such as bridged Terraform providers built atop the `pulumi-terraform-bridge`, for instance) implement
        /// `GetMapping` to support conversion from that ecosystem into Pulumi using the same logic that underpins the
        /// bridging itself.
        async fn get_mapping(
            &self,
            request: tonic::Request<super::GetMappingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMappingResponse>,
            tonic::Status,
        >;
        /// `GetMappings` is an optional method designed to aid in [converting programs and state from other
        /// ecosystems](converters). `GetMappings` accepts a "conversion key". This corresponds to a source language, for
        /// which we want to retrieve mappings for names etc. from that source language into Pulumi. An example key might
        /// therefore be `terraform` in the event that we wish to map e.g. Terraform resource names to Pulumi resource types.
        /// Given a key, `GetMappings` returns a list of *source provider names* for which calls to `GetMapping` will return
        /// mappings. So, continuing the Terraform example, the Pulumi AWS provider, which is bridged from the Terraform AWS
        /// provider and thus capable of mapping names between the two, might return the list `["aws"]` in response to a call
        /// with key `terraform`.
        ///
        /// If a provider does not implement `GetMappings`, the engine will fall back to calling `GetMapping` blindly without
        /// a source provider name (that is, with the value `""`).
        async fn get_mappings(
            &self,
            request: tonic::Request<super::GetMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMappingsResponse>,
            tonic::Status,
        >;
    }
    /// The ResourceProvider service defines a standard interface for [resource providers](providers). A resource provider
    /// manages a set of configuration, resources, functions and so on in a single package, and offers methods such as CRUD
    /// operations on resources and invocations of functions. Resource providers are primarily managed by the Pulumi engine
    /// as part of a deployment in order to interact with the cloud providers underpinning a Pulumi application.
    #[derive(Debug)]
    pub struct ResourceProviderServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ResourceProviderServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ResourceProviderServer<T>
    where
        T: ResourceProvider,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.ResourceProvider/Handshake" => {
                    #[allow(non_camel_case_types)]
                    struct HandshakeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::ProviderHandshakeRequest>
                    for HandshakeSvc<T> {
                        type Response = super::ProviderHandshakeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ProviderHandshakeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::handshake(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HandshakeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Parameterize" => {
                    #[allow(non_camel_case_types)]
                    struct ParameterizeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::ParameterizeRequest>
                    for ParameterizeSvc<T> {
                        type Response = super::ParameterizeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ParameterizeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::parameterize(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ParameterizeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetSchemaSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::GetSchemaRequest>
                    for GetSchemaSvc<T> {
                        type Response = super::GetSchemaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSchemaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/CheckConfig" => {
                    #[allow(non_camel_case_types)]
                    struct CheckConfigSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::CheckRequest>
                    for CheckConfigSvc<T> {
                        type Response = super::CheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::check_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/DiffConfig" => {
                    #[allow(non_camel_case_types)]
                    struct DiffConfigSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::DiffRequest>
                    for DiffConfigSvc<T> {
                        type Response = super::DiffResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DiffRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::diff_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DiffConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Configure" => {
                    #[allow(non_camel_case_types)]
                    struct ConfigureSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::ConfigureRequest>
                    for ConfigureSvc<T> {
                        type Response = super::ConfigureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConfigureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::configure(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConfigureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Invoke" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::InvokeRequest>
                    for InvokeSvc<T> {
                        type Response = super::InvokeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Call" => {
                    #[allow(non_camel_case_types)]
                    struct CallSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::CallRequest> for CallSvc<T> {
                        type Response = super::CallResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::call(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Check" => {
                    #[allow(non_camel_case_types)]
                    struct CheckSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::CheckRequest> for CheckSvc<T> {
                        type Response = super::CheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::check(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Diff" => {
                    #[allow(non_camel_case_types)]
                    struct DiffSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::DiffRequest> for DiffSvc<T> {
                        type Response = super::DiffResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DiffRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::diff(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DiffSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Create" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::CreateRequest>
                    for CreateSvc<T> {
                        type Response = super::CreateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::create(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Read" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::ReadRequest> for ReadSvc<T> {
                        type Response = super::ReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Update" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::UpdateRequest>
                    for UpdateSvc<T> {
                        type Response = super::UpdateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::update(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Delete" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::DeleteRequest>
                    for DeleteSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Construct" => {
                    #[allow(non_camel_case_types)]
                    struct ConstructSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::ConstructRequest>
                    for ConstructSvc<T> {
                        type Response = super::ConstructResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConstructRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::construct(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConstructSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<()>
                    for CancelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetPluginInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetPluginInfoSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<()>
                    for GetPluginInfoSvc<T> {
                        type Response = super::PluginInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_plugin_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPluginInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Attach" => {
                    #[allow(non_camel_case_types)]
                    struct AttachSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::PluginAttach> for AttachSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PluginAttach>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::attach(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AttachSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetMapping" => {
                    #[allow(non_camel_case_types)]
                    struct GetMappingSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::GetMappingRequest>
                    for GetMappingSvc<T> {
                        type Response = super::GetMappingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMappingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_mapping(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMappingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetMappings" => {
                    #[allow(non_camel_case_types)]
                    struct GetMappingsSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<
                        T: ResourceProvider,
                    > tonic::server::UnaryService<super::GetMappingsRequest>
                    for GetMappingsSvc<T> {
                        type Response = super::GetMappingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMappingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_mappings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMappingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ResourceProviderServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.ResourceProvider";
    impl<T> tonic::server::NamedService for ResourceProviderServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// A SourcePosition represents a position in a source file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcePosition {
    /// The URI of the file. Currently only the file scheme with an absolute path is supported.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// The line in the file
    #[prost(int32, tag = "2")]
    pub line: i32,
    /// The column in the line
    #[prost(int32, tag = "3")]
    pub column: i32,
}
/// A StackFrame represents a single stack frame.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackFrame {
    /// The position of the frame's program counter. Optional.
    #[prost(message, optional, tag = "1")]
    pub pc: ::core::option::Option<SourcePosition>,
}
/// A StackTrace represents the frames on the stack at the point of an RPC call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTrace {
    /// The frames on the stack.
    #[prost(message, repeated, tag = "1")]
    pub frames: ::prost::alloc::vec::Vec<StackFrame>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Callback {
    /// the gRPC target of the callback service.
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    /// the service specific unique token for this callback.
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallbackInvokeRequest {
    /// the token for the callback.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// the serialized protobuf message of the arguments for this callback.
    #[prost(bytes = "vec", tag = "2")]
    pub request: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallbackInvokeResponse {
    /// the serialized protobuf message of the response for this callback.
    #[prost(bytes = "vec", tag = "1")]
    pub response: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod callbacks_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Callbacks is a service for invoking functions in one runtime from other processes.
    #[derive(Debug, Clone)]
    pub struct CallbacksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CallbacksClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CallbacksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CallbacksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CallbacksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Invoke invokes a given callback, identified by its token.
        pub async fn invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::CallbackInvokeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CallbackInvokeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Callbacks/Invoke",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Callbacks", "Invoke"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod callbacks_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CallbacksServer.
    #[async_trait]
    pub trait Callbacks: std::marker::Send + std::marker::Sync + 'static {
        /// Invoke invokes a given callback, identified by its token.
        async fn invoke(
            &self,
            request: tonic::Request<super::CallbackInvokeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CallbackInvokeResponse>,
            tonic::Status,
        >;
    }
    /// Callbacks is a service for invoking functions in one runtime from other processes.
    #[derive(Debug)]
    pub struct CallbacksServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CallbacksServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CallbacksServer<T>
    where
        T: Callbacks,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.Callbacks/Invoke" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeSvc<T: Callbacks>(pub Arc<T>);
                    impl<
                        T: Callbacks,
                    > tonic::server::UnaryService<super::CallbackInvokeRequest>
                    for InvokeSvc<T> {
                        type Response = super::CallbackInvokeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CallbackInvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Callbacks>::invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CallbacksServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.Callbacks";
    impl<T> tonic::server::NamedService for CallbacksServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// SupportsFeatureRequest allows a client to test if the resource monitor supports a certain feature, which it may use
/// to control the format or types of messages it sends.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupportsFeatureRequest {
    /// the ID of the feature to test support for.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SupportsFeatureResponse {
    /// true when the resource monitor supports this feature.
    #[prost(bool, tag = "1")]
    pub has_support: bool,
}
/// ReadResourceRequest contains enough information to uniquely qualify and read a resource's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResourceRequest {
    /// the ID of the resource to read.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// the type of the resource object.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// the name, for URN purposes, of the object.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// an optional parent URN that this child resource belongs to.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// optional state sufficient to uniquely identify the resource.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// a list of URNs that this read depends on, as observed by the language host.
    #[prost(string, repeated, tag = "6")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// an optional reference to the provider to use for this read.
    #[prost(string, tag = "7")]
    pub provider: ::prost::alloc::string::String,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "8")]
    pub version: ::prost::alloc::string::String,
    /// when true operations should return secrets as strongly typed.
    #[prost(bool, tag = "9")]
    pub accept_secrets: bool,
    /// a list of output properties that should also be treated as secret, in addition to ones we detect.
    #[prost(string, repeated, tag = "10")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// when true operations should return resource references as strongly typed.
    #[prost(bool, tag = "12")]
    pub accept_resources: bool,
    /// the server url of the provider to use when servicing this request.
    #[prost(string, tag = "13")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums of the provider to use when servicing this request.
    #[prost(map = "string, bytes", tag = "15")]
    pub plugin_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// the optional source position of the user code that initiated the read.
    #[prost(message, optional, tag = "14")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// the optional stack trace at the time of the request.
    #[prost(message, optional, tag = "17")]
    pub stack_trace: ::core::option::Option<StackTrace>,
    /// the optional parent stack trace handle for the request. Supports stitching stack traces across plugins.
    #[prost(string, tag = "18")]
    pub parent_stack_trace_handle: ::prost::alloc::string::String,
    /// a reference from RegisterPackageRequest.
    #[prost(string, tag = "16")]
    pub package_ref: ::prost::alloc::string::String,
}
/// ReadResourceResponse contains the result of reading a resource's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResourceResponse {
    /// the URN for this resource.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// the state of the resource read from the live environment.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
}
/// RegisterResourceRequest contains information about a resource object that was newly allocated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceRequest {
    /// the type of the object allocated.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the name, for URN purposes, of the object.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// an optional parent URN that this child resource belongs to.
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
    /// true if the resource is a custom, managed by a plugin's CRUD operations.
    #[prost(bool, tag = "4")]
    pub custom: bool,
    /// an object produced by the interpreter/source.
    #[prost(message, optional, tag = "5")]
    pub object: ::core::option::Option<::prost_types::Struct>,
    /// true if the resource should be marked protected.
    #[prost(bool, optional, tag = "6")]
    pub protect: ::core::option::Option<bool>,
    /// a list of URNs that this resource depends on, as observed by the language host.
    #[prost(string, repeated, tag = "7")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// an optional reference to the provider to manage this resource's CRUD operations.
    #[prost(string, tag = "8")]
    pub provider: ::prost::alloc::string::String,
    /// a map from property keys to the dependencies of the property.
    #[prost(map = "string, message", tag = "9")]
    pub property_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        register_resource_request::PropertyDependencies,
    >,
    /// true if this resource should be deleted before replacement.
    #[prost(bool, tag = "10")]
    pub delete_before_replace: bool,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "11")]
    pub version: ::prost::alloc::string::String,
    /// a list of property selectors to ignore during updates.
    #[prost(string, repeated, tag = "12")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// when true operations should return secrets as strongly typed.
    #[prost(bool, tag = "13")]
    pub accept_secrets: bool,
    /// a list of output properties that should also be treated as secret, in addition to ones we detect.
    #[prost(string, repeated, tag = "14")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// a list of additional URNs that should be considered the same.
    #[prost(string, repeated, tag = "15")]
    pub alias_ur_ns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// if set, this resource's state should be imported from the given ID.
    #[prost(string, tag = "16")]
    pub import_id: ::prost::alloc::string::String,
    /// ability to pass a custom Timeout block.
    #[prost(message, optional, tag = "17")]
    pub custom_timeouts: ::core::option::Option<
        register_resource_request::CustomTimeouts,
    >,
    /// true if the deleteBeforeReplace property should be treated as defined even if it is false.
    #[prost(bool, tag = "18")]
    pub delete_before_replace_defined: bool,
    /// true if the request is from an SDK that supports partially-known properties during preview.
    #[prost(bool, tag = "19")]
    pub supports_partial_values: bool,
    /// true if the resource is a plugin-managed component resource.
    #[prost(bool, tag = "20")]
    pub remote: bool,
    /// when true operations should return resource references as strongly typed.
    #[prost(bool, tag = "21")]
    pub accept_resources: bool,
    /// an optional reference to the provider map to manage this resource's CRUD operations.
    #[prost(map = "string, string", tag = "22")]
    pub providers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// a list of properties that if changed should force a replacement.
    #[prost(string, repeated, tag = "23")]
    pub replace_on_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the server URL of the provider to use when servicing this request.
    #[prost(string, tag = "24")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums expected for the provider plugin.
    #[prost(map = "string, bytes", tag = "30")]
    pub plugin_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// if true the engine will not call the resource providers delete method for this resource.
    #[prost(bool, optional, tag = "25")]
    pub retain_on_delete: ::core::option::Option<bool>,
    /// a list of additional aliases that should be considered the same.
    #[prost(message, repeated, tag = "26")]
    pub aliases: ::prost::alloc::vec::Vec<Alias>,
    /// if set the engine will not call the resource providers delete method for this resource when specified resource is deleted.
    #[prost(string, tag = "27")]
    pub deleted_with: ::prost::alloc::string::String,
    /// if set the engine will replace this resource when any of the specified resources are replaced.
    #[prost(string, repeated, tag = "38")]
    pub replace_with: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// if set, the engine will diff this with the last recorded value, and trigger a replace if they are not equal.
    #[prost(message, optional, tag = "39")]
    pub replacement_trigger: ::core::option::Option<::prost_types::Value>,
    /// Indicates that alias specs are specified correctly according to the spec.
    /// Older versions of the Node.js SDK did not send alias specs correctly.
    /// If this is not set to true and the engine detects the request is from the
    /// Node.js runtime, the engine will transform incorrect alias specs into
    /// correct ones.
    /// Other SDKs that are correctly specifying alias specs could set this to
    /// true, but it's not necessary.
    #[prost(bool, tag = "28")]
    pub alias_specs: bool,
    /// the optional source position of the user code that initiated the register.
    #[prost(message, optional, tag = "29")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// the optional stack trace at the time of the request.
    #[prost(message, optional, tag = "35")]
    pub stack_trace: ::core::option::Option<StackTrace>,
    /// the optional parent stack trace handle for the request. Supports stitching stack traces across plugins.
    #[prost(string, tag = "36")]
    pub parent_stack_trace_handle: ::prost::alloc::string::String,
    /// a list of transforms to apply to the resource before registering it.
    #[prost(message, repeated, tag = "31")]
    pub transforms: ::prost::alloc::vec::Vec<Callback>,
    /// true if the request is from an SDK that supports the result field in the response.
    #[prost(bool, tag = "32")]
    pub supports_result_reporting: bool,
    /// a reference from RegisterPackageRequest.
    #[prost(string, tag = "33")]
    pub package_ref: ::prost::alloc::string::String,
    /// The resource hooks that should run at certain points in the resource's lifecycle.
    #[prost(message, optional, tag = "34")]
    pub hooks: ::core::option::Option<register_resource_request::ResourceHooksBinding>,
    #[prost(string, repeated, tag = "37")]
    pub hide_diffs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RegisterResourceRequest`.
pub mod register_resource_request {
    /// PropertyDependencies describes the resources that a particular property depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// CustomTimeouts allows a user to be able to create a set of custom timeout parameters.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomTimeouts {
        /// The create resource timeout represented as a string e.g. 5m.
        #[prost(string, tag = "1")]
        pub create: ::prost::alloc::string::String,
        /// The update resource timeout represented as a string e.g. 5m.
        #[prost(string, tag = "2")]
        pub update: ::prost::alloc::string::String,
        /// The delete resource timeout represented as a string e.g. 5m.
        #[prost(string, tag = "3")]
        pub delete: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceHooksBinding {
        #[prost(string, repeated, tag = "1")]
        pub before_create: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub after_create: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub before_update: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub after_update: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "5")]
        pub before_delete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "6")]
        pub after_delete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "7")]
        pub on_error: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// RegisterResourceResponse is returned by the engine after a resource has finished being initialized.  It includes the
/// auto-assigned URN, the provider-assigned ID, and any other properties initialized by the engine.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceResponse {
    /// the URN assigned by the engine.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// the unique ID assigned by the provider.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// the resulting object properties, including provider defaults.
    #[prost(message, optional, tag = "3")]
    pub object: ::core::option::Option<::prost_types::Struct>,
    /// if true, the object's state is stable and may be trusted not to change.
    #[prost(bool, tag = "4")]
    pub stable: bool,
    /// an optional list of guaranteed-stable properties.
    #[prost(string, repeated, tag = "5")]
    pub stables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// a map from property keys to the dependencies of the property.
    #[prost(map = "string, message", tag = "6")]
    pub property_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        register_resource_response::PropertyDependencies,
    >,
    /// the reason, whether the resource registration was successful, failed, or skipped.
    #[prost(enumeration = "Result", tag = "7")]
    pub result: i32,
}
/// Nested message and enum types in `RegisterResourceResponse`.
pub mod register_resource_response {
    /// PropertyDependencies describes the resources that a particular property depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// RegisterResourceOutputsRequest adds extra resource outputs created by the program after registration has occurred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceOutputsRequest {
    /// the URN for the resource to attach output properties to.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// additional output properties to add to the existing resource.
    #[prost(message, optional, tag = "2")]
    pub outputs: ::core::option::Option<::prost_types::Struct>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceInvokeRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// an optional reference to the provider version to use for this invoke.
    #[prost(string, tag = "3")]
    pub provider: ::prost::alloc::string::String,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// when true operations should return resource references as strongly typed.
    #[prost(bool, tag = "5")]
    pub accept_resources: bool,
    /// an optional reference to the provider url to use for this invoke.
    #[prost(string, tag = "6")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums expected for the provider plugin.
    #[prost(map = "string, bytes", tag = "8")]
    pub plugin_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// the optional source position of the user code that initiated the invoke.
    #[prost(message, optional, tag = "7")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// the optional stack trace at the time of the request.
    #[prost(message, optional, tag = "10")]
    pub stack_trace: ::core::option::Option<StackTrace>,
    /// the optional parent stack trace handle for the request. Supports stitching stack traces across plugins.
    #[prost(string, tag = "11")]
    pub parent_stack_trace_handle: ::prost::alloc::string::String,
    /// a reference from RegisterPackageRequest.
    #[prost(string, tag = "9")]
    pub package_ref: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCallRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// a map from argument keys to the dependencies of the argument.
    #[prost(map = "string, message", tag = "3")]
    pub arg_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        resource_call_request::ArgumentDependencies,
    >,
    /// an optional reference to the provider to use for this invoke.
    #[prost(string, tag = "4")]
    pub provider: ::prost::alloc::string::String,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    /// the pluginDownloadURL of the provider to use when servicing this request.
    #[prost(string, tag = "13")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums of the provider to use when servicing this request.
    #[prost(map = "string, bytes", tag = "16")]
    pub plugin_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// the optional source position of the user code that initiated the call.
    #[prost(message, optional, tag = "15")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// the optional stack trace at the time of the request.
    #[prost(message, optional, tag = "18")]
    pub stack_trace: ::core::option::Option<StackTrace>,
    /// the optional parent stack trace handle for the request. Supports stitching stack traces across plugins.
    #[prost(string, tag = "19")]
    pub parent_stack_trace_handle: ::prost::alloc::string::String,
    /// a reference from RegisterPackageRequest.
    #[prost(string, tag = "17")]
    pub package_ref: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ResourceCallRequest`.
pub mod resource_call_request {
    /// ArgumentDependencies describes the resources that a particular argument depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArgumentDependencies {
        /// A list of URNs this argument depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// TransformResourceOptions is a subset of all resource options that are relevant to transforms.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformResourceOptions {
    #[prost(string, repeated, tag = "1")]
    pub depends_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub protect: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "3")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub replace_on_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub aliases: ::prost::alloc::vec::Vec<Alias>,
    #[prost(string, tag = "7")]
    pub provider: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub custom_timeouts: ::core::option::Option<
        register_resource_request::CustomTimeouts,
    >,
    #[prost(string, tag = "9")]
    pub plugin_download_url: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "10")]
    pub retain_on_delete: ::core::option::Option<bool>,
    #[prost(string, tag = "11")]
    pub deleted_with: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "12")]
    pub delete_before_replace: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "13")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "14")]
    pub providers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, bytes", tag = "15")]
    pub plugin_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(message, optional, tag = "16")]
    pub hooks: ::core::option::Option<register_resource_request::ResourceHooksBinding>,
    #[prost(string, tag = "17")]
    pub import: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "18")]
    pub hide_diff: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "19")]
    pub replace_with: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "20")]
    pub replacement_trigger: ::core::option::Option<::prost_types::Value>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformRequest {
    /// the type of the resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the name of the resource.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// true if the resource is a custom resource, else it's a component resource.
    #[prost(bool, tag = "3")]
    pub custom: bool,
    /// the parent of the resource, this can't be changed by the transform.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// the input properties of the resource.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "6")]
    pub options: ::core::option::Option<TransformResourceOptions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformResponse {
    /// the transformed input properties.
    #[prost(message, optional, tag = "1")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<TransformResourceOptions>,
}
/// TransformInvokeRequest is the request object for the TransformInvoke RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInvokeRequest {
    /// the token for the invoke request.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// the input args of the resource.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<TransformInvokeOptions>,
}
/// TransformInvokeResponse is the response object for the TransformInvoke RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInvokeResponse {
    /// the transformed input args.
    #[prost(message, optional, tag = "1")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<TransformInvokeOptions>,
}
/// TransformInvokeOptions is a subset of all invoke options that are relevant to transforms.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInvokeOptions {
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub plugin_download_url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(map = "string, bytes", tag = "4")]
    pub plugin_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// ResourceHookRequest is the request object for resource hook callbacks in CallbackInvokeRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceHookRequest {
    /// the urn of the resource for which the hook is called.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// the optional urn of the resource for which the hook is called.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// the name of the resource for which the hook is called.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// the type of the resource for which the hook is called.
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    /// the optional checked new inputs of the resource.
    #[prost(message, optional, tag = "5")]
    pub new_inputs: ::core::option::Option<::prost_types::Struct>,
    /// the optional checked old inputs of the resource.
    #[prost(message, optional, tag = "6")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// the optional new outputs of the resource.
    #[prost(message, optional, tag = "7")]
    pub new_outputs: ::core::option::Option<::prost_types::Struct>,
    /// the optional old outputs of the resource.
    #[prost(message, optional, tag = "8")]
    pub old_outputs: ::core::option::Option<::prost_types::Struct>,
}
/// ResourceHookResponse is the response object for resource hook callbacks in CallbackInvokeResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceHookResponse {
    /// an optional error message to return from the hook.
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
}
/// ErrorHookRequest is the request object for error hook callbacks in CallbackInvokeRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorHookRequest {
    /// the urn of the resource for which the hook is called.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// the optional urn of the resource for which the hook is called.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// the name of the resource for which the hook is called.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// the type of the resource for which the hook is called.
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    /// the optional checked new inputs of the resource.
    #[prost(message, optional, tag = "5")]
    pub new_inputs: ::core::option::Option<::prost_types::Struct>,
    /// the optional checked old inputs of the resource.
    #[prost(message, optional, tag = "6")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// the optional old outputs of the resource.
    #[prost(message, optional, tag = "7")]
    pub old_outputs: ::core::option::Option<::prost_types::Struct>,
    /// the operation that failed (create, read, update, or delete).
    #[prost(string, tag = "8")]
    pub failed_operation: ::prost::alloc::string::String,
    /// the errors that have been seen so far (newest-first).
    #[prost(string, repeated, tag = "9")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ErrorHookResponse is the response object for error hook callbacks in CallbackInvokeResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorHookResponse {
    /// an optional error message to return from the hook.
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    /// whether we should retry the operation.
    #[prost(bool, tag = "2")]
    pub retry: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterPackageRequest {
    /// the plugin name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the plugin version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the optional plugin download url.
    #[prost(string, tag = "3")]
    pub download_url: ::prost::alloc::string::String,
    /// the optional plugin checksums.
    #[prost(map = "string, bytes", tag = "4")]
    pub checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// the optional parameterization for this package.
    #[prost(message, optional, tag = "5")]
    pub parameterization: ::core::option::Option<Parameterization>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterPackageResponse {
    /// The UUID package reference for this registered package.
    ///
    /// Lifecycle methods accept this reference in the 'packageRef' field.
    #[prost(string, tag = "1")]
    pub r#ref: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameterization {
    /// the parameterized package name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the parameterized package version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the parameter value for the parameterized package.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceHookRequest {
    /// The name of the hook. Must be unique within a program, registering the
    /// same name twice is an error.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the callback that the engine can call to run the hook.
    #[prost(message, optional, tag = "2")]
    pub callback: ::core::option::Option<Callback>,
    /// whether to run the hook on dry runs.
    #[prost(bool, tag = "3")]
    pub on_dry_run: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterErrorHookRequest {
    /// The name of the hook. Must be unique within a program, registering the
    /// same name twice is an error.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the callback that the engine can call to run the hook.
    #[prost(message, optional, tag = "2")]
    pub callback: ::core::option::Option<Callback>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Result {
    Success = 0,
    Fail = 1,
    Skip = 2,
}
impl Result {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Success => "SUCCESS",
            Self::Fail => "FAIL",
            Self::Skip => "SKIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUCCESS" => Some(Self::Success),
            "FAIL" => Some(Self::Fail),
            "SKIP" => Some(Self::Skip),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod resource_monitor_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// ResourceMonitor is the interface a source uses to talk back to the planning monitor orchestrating the execution.
    #[derive(Debug, Clone)]
    pub struct ResourceMonitorClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ResourceMonitorClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ResourceMonitorClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResourceMonitorClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ResourceMonitorClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn supports_feature(
            &mut self,
            request: impl tonic::IntoRequest<super::SupportsFeatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SupportsFeatureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/SupportsFeature",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "SupportsFeature"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::ResourceInvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/Invoke",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "Invoke"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn call(
            &mut self,
            request: impl tonic::IntoRequest<super::ResourceCallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/Call",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "Call"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/ReadResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "ReadResource"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.ResourceMonitor", "RegisterResource"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_resource_outputs(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterResourceOutputsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterResourceOutputs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pulumirpc.ResourceMonitor",
                        "RegisterResourceOutputs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register a resource transform for the stack
        pub async fn register_stack_transform(
            &mut self,
            request: impl tonic::IntoRequest<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterStackTransform",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pulumirpc.ResourceMonitor",
                        "RegisterStackTransform",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register an invoke transform for the stack
        pub async fn register_stack_invoke_transform(
            &mut self,
            request: impl tonic::IntoRequest<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterStackInvokeTransform",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pulumirpc.ResourceMonitor",
                        "RegisterStackInvokeTransform",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register a resource hook that can be called by the engine during certain
        /// steps of a resource's lifecycle.
        pub async fn register_resource_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterResourceHookRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterResourceHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.ResourceMonitor", "RegisterResourceHook"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register an error hook that can be called by the engine when an operation fails and is retryable.
        ///
        /// Error hooks are a separate type of hook to other life cycle hooks as they have different inputs and outputs.
        pub async fn register_error_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterErrorHookRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterErrorHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pulumirpc.ResourceMonitor", "RegisterErrorHook"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Registers a package and allocates a packageRef. The same package can be registered multiple times in Pulumi.
        /// Multiple requests are idempotent and guaranteed to return the same result.
        pub async fn register_package(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterPackageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "RegisterPackage"));
            self.inner.unary(req, path, codec).await
        }
        /// SignalAndWaitForShutdown lets the resource monitor know that no more
        /// events will be generated. This call blocks until the resource monitor is
        /// finished, which will happen once all the steps have executed. This allows
        /// the language runtime to stay running and handle callback requests, even
        /// after the user program has completed. Runtime SDKs should call this after
        /// executing the user's program. This can only be called once.
        pub async fn signal_and_wait_for_shutdown(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/SignalAndWaitForShutdown",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pulumirpc.ResourceMonitor",
                        "SignalAndWaitForShutdown",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod resource_monitor_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ResourceMonitorServer.
    #[async_trait]
    pub trait ResourceMonitor: std::marker::Send + std::marker::Sync + 'static {
        async fn supports_feature(
            &self,
            request: tonic::Request<super::SupportsFeatureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SupportsFeatureResponse>,
            tonic::Status,
        >;
        async fn invoke(
            &self,
            request: tonic::Request<super::ResourceInvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status>;
        async fn call(
            &self,
            request: tonic::Request<super::ResourceCallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status>;
        async fn read_resource(
            &self,
            request: tonic::Request<super::ReadResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadResourceResponse>,
            tonic::Status,
        >;
        async fn register_resource(
            &self,
            request: tonic::Request<super::RegisterResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResourceResponse>,
            tonic::Status,
        >;
        async fn register_resource_outputs(
            &self,
            request: tonic::Request<super::RegisterResourceOutputsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register a resource transform for the stack
        async fn register_stack_transform(
            &self,
            request: tonic::Request<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register an invoke transform for the stack
        async fn register_stack_invoke_transform(
            &self,
            request: tonic::Request<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register a resource hook that can be called by the engine during certain
        /// steps of a resource's lifecycle.
        async fn register_resource_hook(
            &self,
            request: tonic::Request<super::RegisterResourceHookRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register an error hook that can be called by the engine when an operation fails and is retryable.
        ///
        /// Error hooks are a separate type of hook to other life cycle hooks as they have different inputs and outputs.
        async fn register_error_hook(
            &self,
            request: tonic::Request<super::RegisterErrorHookRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Registers a package and allocates a packageRef. The same package can be registered multiple times in Pulumi.
        /// Multiple requests are idempotent and guaranteed to return the same result.
        async fn register_package(
            &self,
            request: tonic::Request<super::RegisterPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterPackageResponse>,
            tonic::Status,
        >;
        /// SignalAndWaitForShutdown lets the resource monitor know that no more
        /// events will be generated. This call blocks until the resource monitor is
        /// finished, which will happen once all the steps have executed. This allows
        /// the language runtime to stay running and handle callback requests, even
        /// after the user program has completed. Runtime SDKs should call this after
        /// executing the user's program. This can only be called once.
        async fn signal_and_wait_for_shutdown(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    /// ResourceMonitor is the interface a source uses to talk back to the planning monitor orchestrating the execution.
    #[derive(Debug)]
    pub struct ResourceMonitorServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ResourceMonitorServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ResourceMonitorServer<T>
    where
        T: ResourceMonitor,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.ResourceMonitor/SupportsFeature" => {
                    #[allow(non_camel_case_types)]
                    struct SupportsFeatureSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::SupportsFeatureRequest>
                    for SupportsFeatureSvc<T> {
                        type Response = super::SupportsFeatureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SupportsFeatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::supports_feature(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SupportsFeatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/Invoke" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::ResourceInvokeRequest>
                    for InvokeSvc<T> {
                        type Response = super::InvokeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResourceInvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/Call" => {
                    #[allow(non_camel_case_types)]
                    struct CallSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::ResourceCallRequest>
                    for CallSvc<T> {
                        type Response = super::CallResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResourceCallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::call(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/ReadResource" => {
                    #[allow(non_camel_case_types)]
                    struct ReadResourceSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::ReadResourceRequest>
                    for ReadResourceSvc<T> {
                        type Response = super::ReadResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::read_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterResource" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterResourceSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::RegisterResourceRequest>
                    for RegisterResourceSvc<T> {
                        type Response = super::RegisterResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_resource(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterResourceOutputs" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterResourceOutputsSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::RegisterResourceOutputsRequest>
                    for RegisterResourceOutputsSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::RegisterResourceOutputsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_resource_outputs(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterResourceOutputsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterStackTransform" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterStackTransformSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor> tonic::server::UnaryService<super::Callback>
                    for RegisterStackTransformSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Callback>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_stack_transform(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterStackTransformSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterStackInvokeTransform" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterStackInvokeTransformSvc<T: ResourceMonitor>(
                        pub Arc<T>,
                    );
                    impl<T: ResourceMonitor> tonic::server::UnaryService<super::Callback>
                    for RegisterStackInvokeTransformSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Callback>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_stack_invoke_transform(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterStackInvokeTransformSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterResourceHook" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterResourceHookSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::RegisterResourceHookRequest>
                    for RegisterResourceHookSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterResourceHookRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_resource_hook(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterResourceHookSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterErrorHook" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterErrorHookSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::RegisterErrorHookRequest>
                    for RegisterErrorHookSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterErrorHookRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_error_hook(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterErrorHookSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterPackage" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterPackageSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<
                        T: ResourceMonitor,
                    > tonic::server::UnaryService<super::RegisterPackageRequest>
                    for RegisterPackageSvc<T> {
                        type Response = super::RegisterPackageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterPackageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_package(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterPackageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/SignalAndWaitForShutdown" => {
                    #[allow(non_camel_case_types)]
                    struct SignalAndWaitForShutdownSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor> tonic::server::UnaryService<()>
                    for SignalAndWaitForShutdownSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::signal_and_wait_for_shutdown(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignalAndWaitForShutdownSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ResourceMonitorServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.ResourceMonitor";
    impl<T> tonic::server::NamedService for ResourceMonitorServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogRequest {
    /// the logging level of this message.
    #[prost(enumeration = "LogSeverity", tag = "1")]
    pub severity: i32,
    /// the contents of the logged message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// the (optional) resource urn this log is associated with.
    #[prost(string, tag = "3")]
    pub urn: ::prost::alloc::string::String,
    /// the (optional) stream id that a stream of log messages can be associated with. This allows
    /// clients to not have to buffer a large set of log messages that they all want to be
    /// conceptually connected.  Instead the messages can be sent as chunks (with the same stream id)
    /// and the end display can show the messages as they arrive, while still stitching them together
    /// into one total log message.
    ///
    /// 0/not-given means: do not associate with any stream.
    #[prost(int32, tag = "4")]
    pub stream_id: i32,
    /// Optional value indicating whether this is a status message.
    #[prost(bool, tag = "5")]
    pub ephemeral: bool,
}
/// empty.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRootResourceRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRootResourceResponse {
    /// the URN of the root resource, or the empty string if one was not set.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRootResourceRequest {
    /// the URN of the root resource, or the empty string.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
}
/// empty.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRootResourceResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartDebuggingRequest {
    /// the debug configuration parameters.  These are meant to be in the right format for the DAP protocol to consume.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<::prost_types::Struct>,
    /// the string to display to the user with instructions on how to connect to the debugger.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequirePulumiVersionRequest {
    /// A version range to check against the engine (CLI) version. If the version is not compatible with the specified
    /// range, an error is returned. The supported syntax for ranges is that of
    /// <https://pkg.go.dev/github.com/blang/semver#ParseRange.> For example ">=3.0.0", or "!3.1.2". Ranges can be AND-ed
    /// together by concatenating with spaces ">=3.5.0 !3.7.7", meaning greater-or-equal to 3.5.0 and not exactly 3.7.7.
    /// Ranges can be OR-ed with the `||` operator: "<3.4.0 || >3.8.0", meaning less-than 3.4.0 or greater-than 3.8.0.
    #[prost(string, tag = "1")]
    pub pulumi_version_range: ::prost::alloc::string::String,
}
/// empty
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequirePulumiVersionResponse {}
/// LogSeverity is the severity level of a log message.  Errors are fatal; all others are informational.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogSeverity {
    /// a debug-level message not displayed to end-users (the default).
    Debug = 0,
    /// an informational message printed to output during resource operations.
    Info = 1,
    /// a warning to indicate that something went wrong.
    Warning = 2,
    /// a fatal error indicating that the tool should stop processing subsequent resource operations.
    Error = 3,
}
impl LogSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Debug => "DEBUG",
            Self::Info => "INFO",
            Self::Warning => "WARNING",
            Self::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEBUG" => Some(Self::Debug),
            "INFO" => Some(Self::Info),
            "WARNING" => Some(Self::Warning),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod engine_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Engine is an auxiliary service offered to language and resource provider plugins. Its main purpose today is
    /// to serve as a common logging endpoint, but it also serves as a state storage mechanism for language hosts
    /// that can't store their own global state.
    #[derive(Debug, Clone)]
    pub struct EngineClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EngineClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EngineClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EngineClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EngineClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Log logs a global message in the engine, including errors and warnings.
        pub async fn log(
            &mut self,
            request: impl tonic::IntoRequest<super::LogRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.Engine/Log");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("pulumirpc.Engine", "Log"));
            self.inner.unary(req, path, codec).await
        }
        /// GetRootResource gets the URN of the root resource, the resource that should be the root of all
        /// otherwise-unparented resources.
        pub async fn get_root_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRootResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRootResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Engine/GetRootResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "GetRootResource"));
            self.inner.unary(req, path, codec).await
        }
        /// SetRootResource sets the URN of the root resource.
        pub async fn set_root_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRootResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRootResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Engine/SetRootResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "SetRootResource"));
            self.inner.unary(req, path, codec).await
        }
        /// StartDebugging indicates to the engine that the program has started under a debugger, and the engine
        /// should notify the user of how to connect to the debugger.
        pub async fn start_debugging(
            &mut self,
            request: impl tonic::IntoRequest<super::StartDebuggingRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Engine/StartDebugging",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "StartDebugging"));
            self.inner.unary(req, path, codec).await
        }
        /// RequirePulumiVersion checks that the version of the engine satisfies the passed in range.
        pub async fn require_pulumi_version(
            &mut self,
            request: impl tonic::IntoRequest<super::RequirePulumiVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequirePulumiVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Engine/RequirePulumiVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "RequirePulumiVersion"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod engine_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with EngineServer.
    #[async_trait]
    pub trait Engine: std::marker::Send + std::marker::Sync + 'static {
        /// Log logs a global message in the engine, including errors and warnings.
        async fn log(
            &self,
            request: tonic::Request<super::LogRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// GetRootResource gets the URN of the root resource, the resource that should be the root of all
        /// otherwise-unparented resources.
        async fn get_root_resource(
            &self,
            request: tonic::Request<super::GetRootResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRootResourceResponse>,
            tonic::Status,
        >;
        /// SetRootResource sets the URN of the root resource.
        async fn set_root_resource(
            &self,
            request: tonic::Request<super::SetRootResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRootResourceResponse>,
            tonic::Status,
        >;
        /// StartDebugging indicates to the engine that the program has started under a debugger, and the engine
        /// should notify the user of how to connect to the debugger.
        async fn start_debugging(
            &self,
            request: tonic::Request<super::StartDebuggingRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// RequirePulumiVersion checks that the version of the engine satisfies the passed in range.
        async fn require_pulumi_version(
            &self,
            request: tonic::Request<super::RequirePulumiVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequirePulumiVersionResponse>,
            tonic::Status,
        >;
    }
    /// Engine is an auxiliary service offered to language and resource provider plugins. Its main purpose today is
    /// to serve as a common logging endpoint, but it also serves as a state storage mechanism for language hosts
    /// that can't store their own global state.
    #[derive(Debug)]
    pub struct EngineServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> EngineServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for EngineServer<T>
    where
        T: Engine,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.Engine/Log" => {
                    #[allow(non_camel_case_types)]
                    struct LogSvc<T: Engine>(pub Arc<T>);
                    impl<T: Engine> tonic::server::UnaryService<super::LogRequest>
                    for LogSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LogRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::log(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LogSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/GetRootResource" => {
                    #[allow(non_camel_case_types)]
                    struct GetRootResourceSvc<T: Engine>(pub Arc<T>);
                    impl<
                        T: Engine,
                    > tonic::server::UnaryService<super::GetRootResourceRequest>
                    for GetRootResourceSvc<T> {
                        type Response = super::GetRootResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRootResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::get_root_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRootResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/SetRootResource" => {
                    #[allow(non_camel_case_types)]
                    struct SetRootResourceSvc<T: Engine>(pub Arc<T>);
                    impl<
                        T: Engine,
                    > tonic::server::UnaryService<super::SetRootResourceRequest>
                    for SetRootResourceSvc<T> {
                        type Response = super::SetRootResourceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetRootResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::set_root_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetRootResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/StartDebugging" => {
                    #[allow(non_camel_case_types)]
                    struct StartDebuggingSvc<T: Engine>(pub Arc<T>);
                    impl<
                        T: Engine,
                    > tonic::server::UnaryService<super::StartDebuggingRequest>
                    for StartDebuggingSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartDebuggingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::start_debugging(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartDebuggingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/RequirePulumiVersion" => {
                    #[allow(non_camel_case_types)]
                    struct RequirePulumiVersionSvc<T: Engine>(pub Arc<T>);
                    impl<
                        T: Engine,
                    > tonic::server::UnaryService<super::RequirePulumiVersionRequest>
                    for RequirePulumiVersionSvc<T> {
                        type Response = super::RequirePulumiVersionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequirePulumiVersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::require_pulumi_version(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequirePulumiVersionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for EngineServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.Engine";
    impl<T> tonic::server::NamedService for EngineServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertStateRequest {
    /// the gRPC target of the mapper service.
    #[prost(string, tag = "1")]
    pub mapper_target: ::prost::alloc::string::String,
    /// the args passed to `pulumi import` for this conversion. Normally used to specifiy a state file to
    /// import from.
    #[prost(string, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A ResourceImport specifies a resource to import.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceImport {
    /// the type token for the resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the name of the resource.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// the ID of the resource.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    /// the provider version to use for the resource, if any.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// the provider PluginDownloadURL to use for the resource, if any.
    #[prost(string, tag = "5")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// the logical name of the resource.
    #[prost(string, tag = "6")]
    pub logical_name: ::prost::alloc::string::String,
    /// true if this is a component resource.
    #[prost(bool, tag = "7")]
    pub is_component: bool,
    /// true if this is a remote resource. Ignored if is_component is false.
    #[prost(bool, tag = "8")]
    pub is_remote: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertStateResponse {
    /// a list of resources to import.
    #[prost(message, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<ResourceImport>,
    /// any diagnostics from state conversion.
    #[prost(message, repeated, tag = "2")]
    pub diagnostics: ::prost::alloc::vec::Vec<codegen::Diagnostic>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertProgramRequest {
    /// the source directory containing the program to convert from.
    #[prost(string, tag = "1")]
    pub source_directory: ::prost::alloc::string::String,
    /// a target directory to write the resulting PCL code and project file to.
    #[prost(string, tag = "2")]
    pub target_directory: ::prost::alloc::string::String,
    /// the gRPC target of the mapper service.
    #[prost(string, tag = "3")]
    pub mapper_target: ::prost::alloc::string::String,
    /// The target of a codegen.LoaderServer to use for loading schemas.
    #[prost(string, tag = "4")]
    pub loader_target: ::prost::alloc::string::String,
    /// the args passed to `pulumi convert` for this conversion. Normally used to specifiy a root file, or conversion options.
    #[prost(string, repeated, tag = "5")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the directory where the final generated project for the eventual destination language will be written.
    /// use to determine relative paths of any asset that will be copied over.
    /// Do not write files to this directory as these files might be overwritten in
    /// the project generation process.
    #[prost(string, tag = "6")]
    pub generated_project_directory: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertProgramResponse {
    /// any diagnostics from code generation.
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<codegen::Diagnostic>,
}
/// Generated client implementations.
pub mod converter_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Converter is a service for converting between other ecosystems and Pulumi.
    /// This is currently unstable and experimental.
    #[derive(Debug, Clone)]
    pub struct ConverterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConverterClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConverterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConverterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConverterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// ConvertState converts state from the target ecosystem into a form that can be imported into Pulumi.
        pub async fn convert_state(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Converter/ConvertState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Converter", "ConvertState"));
            self.inner.unary(req, path, codec).await
        }
        /// ConvertProgram converts a program from the target ecosystem into a form that can be used with Pulumi.
        pub async fn convert_program(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertProgramResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Converter/ConvertProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Converter", "ConvertProgram"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod converter_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConverterServer.
    #[async_trait]
    pub trait Converter: std::marker::Send + std::marker::Sync + 'static {
        /// ConvertState converts state from the target ecosystem into a form that can be imported into Pulumi.
        async fn convert_state(
            &self,
            request: tonic::Request<super::ConvertStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertStateResponse>,
            tonic::Status,
        >;
        /// ConvertProgram converts a program from the target ecosystem into a form that can be used with Pulumi.
        async fn convert_program(
            &self,
            request: tonic::Request<super::ConvertProgramRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertProgramResponse>,
            tonic::Status,
        >;
    }
    /// Converter is a service for converting between other ecosystems and Pulumi.
    /// This is currently unstable and experimental.
    #[derive(Debug)]
    pub struct ConverterServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConverterServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ConverterServer<T>
    where
        T: Converter,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.Converter/ConvertState" => {
                    #[allow(non_camel_case_types)]
                    struct ConvertStateSvc<T: Converter>(pub Arc<T>);
                    impl<
                        T: Converter,
                    > tonic::server::UnaryService<super::ConvertStateRequest>
                    for ConvertStateSvc<T> {
                        type Response = super::ConvertStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConvertStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Converter>::convert_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConvertStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Converter/ConvertProgram" => {
                    #[allow(non_camel_case_types)]
                    struct ConvertProgramSvc<T: Converter>(pub Arc<T>);
                    impl<
                        T: Converter,
                    > tonic::server::UnaryService<super::ConvertProgramRequest>
                    for ConvertProgramSvc<T> {
                        type Response = super::ConvertProgramResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConvertProgramRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Converter>::convert_program(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConvertProgramSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConverterServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.Converter";
    impl<T> tonic::server::NamedService for ConverterServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// `AnalyzerStackConfigureRequest` is the message for the stack configuration of the stack being analyzed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerStackConfigureRequest {
    /// The stack name being analyzed.
    #[prost(string, tag = "1")]
    pub stack: ::prost::alloc::string::String,
    /// The project name of the stack being analyzed.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The organization name of the stack being analyzed.
    #[prost(string, tag = "3")]
    pub organization: ::prost::alloc::string::String,
    /// True if this is a preview/dry run.
    #[prost(bool, tag = "4")]
    pub dry_run: bool,
    /// A list of configuration keys whose values should be treated as secrets.
    #[prost(string, repeated, tag = "6")]
    pub config_secret_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The configuration of the stack being analyzed.
    #[prost(map = "string, string", tag = "7")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Tags for the current stack.
    #[prost(map = "string, string", tag = "8")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// `AnalyzerStackConfigureResponse` is the type of responses sent by a [](pulumirpc.Analyzer.ConfigureStack) call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalyzerStackConfigureResponse {}
/// `AnalyzerHandshakeRequest` is the type of requests sent as part of a [](pulumirpc.Analyzer.Handshake) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerHandshakeRequest {
    /// The gRPC address of the engine handshaking with the analyzer. At a minimum, this address will expose an instance
    /// of the [](pulumirpc.Engine) service.
    #[prost(string, tag = "1")]
    pub engine_address: ::prost::alloc::string::String,
    /// A *root directory* where the analyzer's binary, `PulumiPolicy.yaml`, or other identifying source code is located.
    /// In the event that the analyzer is *not* being booted by the engine (e.g. in the case that the engine has been
    /// asked to attach to an existing running analyzer instance via a host/port number), this field will be empty.
    #[prost(string, optional, tag = "2")]
    pub root_directory: ::core::option::Option<::prost::alloc::string::String>,
    /// A *program directory* in which the analyzer should execute. This is generally a subdirectory of the root
    /// directory, though this is not required. In the event that the analyzer is *not* being booted by the engine (e.g.
    /// in the case that the engine has been asked to attach to an existing running analyzer instance via a host/port
    /// number), this field will be empty.
    #[prost(string, optional, tag = "3")]
    pub program_directory: ::core::option::Option<::prost::alloc::string::String>,
}
/// `AnalyzerHandshakeResponse` is the type of responses sent by a [](pulumirpc.Analyzer.Handshake) call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalyzerHandshakeResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeRequest {
    /// the type token of the resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the full properties to use for validation.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the URN of the resource.
    #[prost(string, tag = "3")]
    pub urn: ::prost::alloc::string::String,
    /// the name for the resource's URN.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// the resource options.
    #[prost(message, optional, tag = "5")]
    pub options: ::core::option::Option<AnalyzerResourceOptions>,
    /// the resource's provider.
    #[prost(message, optional, tag = "6")]
    pub provider: ::core::option::Option<AnalyzerProviderResource>,
}
/// AnalyzerResource defines the view of a Pulumi-managed resource as sent to Analyzers. The properties
/// of the resource are specific to the type of analysis being performed. See the Analyzer
/// service definition for more information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerResource {
    /// the type token of the resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the full properties to use for validation.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the URN of the resource.
    #[prost(string, tag = "3")]
    pub urn: ::prost::alloc::string::String,
    /// the name for the resource's URN.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// the resource options.
    #[prost(message, optional, tag = "5")]
    pub options: ::core::option::Option<AnalyzerResourceOptions>,
    /// the resource's provider.
    #[prost(message, optional, tag = "6")]
    pub provider: ::core::option::Option<AnalyzerProviderResource>,
    /// an optional parent URN that this child resource belongs to.
    #[prost(string, tag = "7")]
    pub parent: ::prost::alloc::string::String,
    /// a list of URNs that this resource depends on.
    #[prost(string, repeated, tag = "8")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// a map from property keys to the dependencies of the property.
    #[prost(map = "string, message", tag = "9")]
    pub property_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AnalyzerPropertyDependencies,
    >,
}
/// AnalyzerResourceOptions defines the options associated with a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerResourceOptions {
    /// true if the resource should be marked protected.
    #[prost(bool, tag = "1")]
    pub protect: bool,
    /// a list of property names to ignore during changes.
    #[prost(string, repeated, tag = "2")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// true if this resource should be deleted before replacement.
    #[prost(bool, tag = "3")]
    pub delete_before_replace: bool,
    /// true if the deleteBeforeReplace property should be treated as defined even if it is false.
    #[prost(bool, tag = "4")]
    pub delete_before_replace_defined: bool,
    /// a list of output properties that should also be treated as secret, in addition to ones we detect.
    #[prost(string, repeated, tag = "5")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// a list of additional URNs that shoud be considered the same.
    #[prost(string, repeated, tag = "6")]
    pub aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// a config block that will be used to configure timeouts for CRUD operations.
    #[prost(message, optional, tag = "7")]
    pub custom_timeouts: ::core::option::Option<
        analyzer_resource_options::CustomTimeouts,
    >,
    /// an optional parent URN that this child resource belongs to.
    #[prost(string, tag = "8")]
    pub parent: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AnalyzerResourceOptions`.
pub mod analyzer_resource_options {
    /// CustomTimeouts allows a user to be able to create a set of custom timeout parameters.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CustomTimeouts {
        /// The create resource timeout in seconds.
        #[prost(double, tag = "1")]
        pub create: f64,
        /// The update resource timeout in seconds.
        #[prost(double, tag = "2")]
        pub update: f64,
        /// The delete resource timeout in seconds.
        #[prost(double, tag = "3")]
        pub delete: f64,
    }
}
/// AnalyzerProviderResource provides information about a resource's provider.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerProviderResource {
    /// the type token of the resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the full properties to use for validation.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the URN of the resource.
    #[prost(string, tag = "3")]
    pub urn: ::prost::alloc::string::String,
    /// the name for the resource's URN.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
/// AnalyzerPropertyDependencies describes the resources that a particular property depends on.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerPropertyDependencies {
    /// A list of URNs this property depends on.
    #[prost(string, repeated, tag = "1")]
    pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeStackRequest {
    #[prost(message, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<AnalyzerResource>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeResponse {
    /// information about policy violations.
    #[prost(message, repeated, tag = "2")]
    pub diagnostics: ::prost::alloc::vec::Vec<AnalyzeDiagnostic>,
    /// information about policies that were not applicable.
    #[prost(message, repeated, tag = "3")]
    pub not_applicable: ::prost::alloc::vec::Vec<PolicyNotApplicable>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeDiagnostic {
    /// Name of the violated policy.
    #[prost(string, tag = "1")]
    pub policy_name: ::prost::alloc::string::String,
    /// Name of the policy pack the policy is in.
    #[prost(string, tag = "2")]
    pub policy_pack_name: ::prost::alloc::string::String,
    /// Version of the policy pack.
    #[prost(string, tag = "3")]
    pub policy_pack_version: ::prost::alloc::string::String,
    /// Description of policy rule. e.g., "encryption enabled."
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Message to display on policy violation, e.g., remediation steps.
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    /// Enforcement level of the policy violation.
    #[prost(enumeration = "EnforcementLevel", tag = "7")]
    pub enforcement_level: i32,
    /// URN of the resource that violates the policy.
    #[prost(string, tag = "8")]
    pub urn: ::prost::alloc::string::String,
    /// Severity of the policy violation.
    #[prost(enumeration = "PolicySeverity", tag = "9")]
    pub severity: i32,
}
/// Remediation is a single resource remediation result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Remediation {
    /// Name of the policy that performed the remediation.
    #[prost(string, tag = "1")]
    pub policy_name: ::prost::alloc::string::String,
    /// Name of the policy pack the transform is in.
    #[prost(string, tag = "2")]
    pub policy_pack_name: ::prost::alloc::string::String,
    /// Version of the policy pack.
    #[prost(string, tag = "3")]
    pub policy_pack_version: ::prost::alloc::string::String,
    /// Description of transform rule. e.g., "auto-tag resources."
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// the transformed properties to use.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// an optional warning diagnostic to emit, if a transform failed.
    #[prost(string, tag = "6")]
    pub diagnostic: ::prost::alloc::string::String,
}
/// RemediateResponse contains a sequence of remediations applied, in order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemediateResponse {
    /// the list of remediations that were applied.
    #[prost(message, repeated, tag = "1")]
    pub remediations: ::prost::alloc::vec::Vec<Remediation>,
    /// information about policies that were not applicable.
    #[prost(message, repeated, tag = "2")]
    pub not_applicable: ::prost::alloc::vec::Vec<PolicyNotApplicable>,
}
/// AnalyzerInfo provides metadata about a PolicyPack inside an analyzer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerInfo {
    /// Name of the PolicyPack.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Pretty name for the PolicyPack.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Metadata about policies contained in PolicyPack.
    #[prost(message, repeated, tag = "3")]
    pub policies: ::prost::alloc::vec::Vec<PolicyInfo>,
    /// Version of the Policy Pack.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// Whether the Policy Pack supports config.
    #[prost(bool, tag = "5")]
    pub supports_config: bool,
    /// Map of policy name to config.
    #[prost(map = "string, message", tag = "6")]
    pub initial_config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PolicyConfig,
    >,
    /// Description of the policy pack.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// README text for the policy pack.
    #[prost(string, tag = "8")]
    pub readme: ::prost::alloc::string::String,
    /// Cloud provider/platform associated with the policy pack.
    #[prost(string, tag = "9")]
    pub provider: ::prost::alloc::string::String,
    /// Tags for this policy pack.
    #[prost(string, repeated, tag = "10")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A URL to the repository where the policy pack is defined.
    #[prost(string, tag = "11")]
    pub repository: ::prost::alloc::string::String,
}
/// PolicyInfo provides metadata about a policy within a Policy Pack.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyInfo {
    /// Name of the policy.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Pretty name for the policy.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Description of policy rule. e.g., "encryption enabled."
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Message to display on policy violation, e.g., remediation steps.
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    /// Severity of the policy violation.
    #[prost(enumeration = "EnforcementLevel", tag = "5")]
    pub enforcement_level: i32,
    /// Config schema for the policy.
    #[prost(message, optional, tag = "6")]
    pub config_schema: ::core::option::Option<PolicyConfigSchema>,
    /// Type of the policy.
    #[prost(enumeration = "PolicyType", tag = "7")]
    pub policy_type: i32,
    /// Severity of the policy.
    #[prost(enumeration = "PolicySeverity", tag = "8")]
    pub severity: i32,
    /// Compliance framework that this policy belongs to.
    #[prost(message, optional, tag = "9")]
    pub framework: ::core::option::Option<PolicyComplianceFramework>,
    /// Tags associated with the policy.
    #[prost(string, repeated, tag = "10")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A description of the steps to take to remediate a policy violation.
    #[prost(string, tag = "11")]
    pub remediation_steps: ::prost::alloc::string::String,
    /// A URL to more information about the policy.
    #[prost(string, tag = "12")]
    pub url: ::prost::alloc::string::String,
}
/// PolicyConfigSchema provides the schema for a policy's configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyConfigSchema {
    /// JSON schema for each property.
    #[prost(message, optional, tag = "1")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Required properties.
    #[prost(string, repeated, tag = "2")]
    pub required: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// PolicyConfig provides configuration for a policy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyConfig {
    /// Enforcement level of the policy.
    #[prost(enumeration = "EnforcementLevel", tag = "1")]
    pub enforcement_level: i32,
    /// Configuration properties of the policy.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
}
/// ConfigureAnalyzerRequest provides configuration information to the analyzer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureAnalyzerRequest {
    /// Map of policy name to config.
    #[prost(map = "string, message", tag = "1")]
    pub policy_config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PolicyConfig,
    >,
}
/// PolicyComplianceFramework provides information about the compliance framework that a policy belongs to.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyComplianceFramework {
    /// The compliance framework name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The compliance framework version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// The compliance framework reference.
    #[prost(string, tag = "3")]
    pub reference: ::prost::alloc::string::String,
    /// The compliance framework specification.
    #[prost(string, tag = "4")]
    pub specification: ::prost::alloc::string::String,
}
/// PolicyNotApplicable describes a policy that was not applicable, including an optional reason why.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyNotApplicable {
    /// The name of the policy that was not applicable.
    #[prost(string, tag = "1")]
    pub policy_name: ::prost::alloc::string::String,
    /// An optional reason why the policy was not applicable.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// EnforcementLevel indicates the severity of a policy violation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnforcementLevel {
    /// Displayed to users, but does not block deployment.
    Advisory = 0,
    /// Stops deployment, cannot be overridden.
    Mandatory = 1,
    /// Disabled policies do not run during a deployment.
    Disabled = 2,
    /// Remediated policies actually fixes problems instead of issuing diagnostics.
    Remediate = 3,
}
impl EnforcementLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Advisory => "ADVISORY",
            Self::Mandatory => "MANDATORY",
            Self::Disabled => "DISABLED",
            Self::Remediate => "REMEDIATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADVISORY" => Some(Self::Advisory),
            "MANDATORY" => Some(Self::Mandatory),
            "DISABLED" => Some(Self::Disabled),
            "REMEDIATE" => Some(Self::Remediate),
            _ => None,
        }
    }
}
/// PolicyType indicates the type of a policy.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PolicyType {
    /// Unknown policy type.
    Unknown = 0,
    /// A policy that validates a resource.
    Resource = 1,
    /// A policy that validates a stack.
    Stack = 2,
}
impl PolicyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "POLICY_TYPE_UNKNOWN",
            Self::Resource => "POLICY_TYPE_RESOURCE",
            Self::Stack => "POLICY_TYPE_STACK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLICY_TYPE_UNKNOWN" => Some(Self::Unknown),
            "POLICY_TYPE_RESOURCE" => Some(Self::Resource),
            "POLICY_TYPE_STACK" => Some(Self::Stack),
            _ => None,
        }
    }
}
/// PolicySeverity indicates the severity of a policy.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PolicySeverity {
    /// Unspecified severity.
    Unspecified = 0,
    /// Low severity.
    Low = 1,
    /// Medium severity.
    Medium = 2,
    /// High severity.
    High = 3,
    /// Critical severity.
    Critical = 4,
}
impl PolicySeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "POLICY_SEVERITY_UNSPECIFIED",
            Self::Low => "POLICY_SEVERITY_LOW",
            Self::Medium => "POLICY_SEVERITY_MEDIUM",
            Self::High => "POLICY_SEVERITY_HIGH",
            Self::Critical => "POLICY_SEVERITY_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POLICY_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "POLICY_SEVERITY_LOW" => Some(Self::Low),
            "POLICY_SEVERITY_MEDIUM" => Some(Self::Medium),
            "POLICY_SEVERITY_HIGH" => Some(Self::High),
            "POLICY_SEVERITY_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod analyzer_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Analyzer provides a pluggable interface for checking resource definitions against some number of
    /// resource policies. It is intentionally open-ended, allowing for implementations that check
    /// everything from raw resource definitions to entire projects/stacks/snapshots for arbitrary
    /// issues -- style, policy, correctness, security, and so on.
    #[derive(Debug, Clone)]
    pub struct AnalyzerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AnalyzerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AnalyzerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AnalyzerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AnalyzerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Analyze analyzes a single resource object, and returns any errors that it finds.
        /// Called with the "inputs" to the resource, before it is updated.
        pub async fn analyze(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/Analyze",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "Analyze"));
            self.inner.unary(req, path, codec).await
        }
        /// AnalyzeStack analyzes all resources within a stack, at the end of a successful
        /// preview or update. The provided resources are the "outputs", after any mutations
        /// have taken place.
        pub async fn analyze_stack(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzeStackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/AnalyzeStack",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "AnalyzeStack"));
            self.inner.unary(req, path, codec).await
        }
        /// Remediate optionally transforms a single resource object. This effectively rewrites
        /// a single resource object's properties instead of using what was generated by the program.
        pub async fn remediate(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemediateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/Remediate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "Remediate"));
            self.inner.unary(req, path, codec).await
        }
        /// GetAnalyzerInfo returns metadata about the analyzer (e.g., list of policies contained).
        pub async fn get_analyzer_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::AnalyzerInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/GetAnalyzerInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "GetAnalyzerInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// GetPluginInfo returns generic information about this plugin, like its version.
        pub async fn get_plugin_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/GetPluginInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "GetPluginInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Configure configures the analyzer, passing configuration properties for each policy.
        pub async fn configure(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfigureAnalyzerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/Configure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "Configure"));
            self.inner.unary(req, path, codec).await
        }
        /// `Handshake` is the first call made by the engine to an analyzer. It is used to pass the engine's address to the
        /// analyzer so that it may establish its own connections back, and to establish protocol configuration that will be
        /// used to communicate between the two parties.
        pub async fn handshake(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzerHandshakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzerHandshakeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/Handshake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "Handshake"));
            self.inner.unary(req, path, codec).await
        }
        /// `ConfigureStack` is always called if the engine is using the analyzer to analyze resources in a specific stack.
        /// This method is not always called, for example if the engine is just booting the analyzer up to call
        /// GetAnalyzerInfo.
        pub async fn configure_stack(
            &mut self,
            request: impl tonic::IntoRequest<super::AnalyzerStackConfigureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzerStackConfigureResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/ConfigureStack",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Analyzer", "ConfigureStack"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel signals the analyzer to gracefully shut down and abort any ongoing analysis operations.
        /// Operations aborted in this way will return an error. Since Cancel is advisory and non-blocking,
        /// it is up to the host to decide how long to wait after Cancel is called before (e.g.)
        /// hard-closing any gRPC connection.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.Analyzer/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("pulumirpc.Analyzer", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod analyzer_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AnalyzerServer.
    #[async_trait]
    pub trait Analyzer: std::marker::Send + std::marker::Sync + 'static {
        /// Analyze analyzes a single resource object, and returns any errors that it finds.
        /// Called with the "inputs" to the resource, before it is updated.
        async fn analyze(
            &self,
            request: tonic::Request<super::AnalyzeRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalyzeResponse>, tonic::Status>;
        /// AnalyzeStack analyzes all resources within a stack, at the end of a successful
        /// preview or update. The provided resources are the "outputs", after any mutations
        /// have taken place.
        async fn analyze_stack(
            &self,
            request: tonic::Request<super::AnalyzeStackRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalyzeResponse>, tonic::Status>;
        /// Remediate optionally transforms a single resource object. This effectively rewrites
        /// a single resource object's properties instead of using what was generated by the program.
        async fn remediate(
            &self,
            request: tonic::Request<super::AnalyzeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemediateResponse>,
            tonic::Status,
        >;
        /// GetAnalyzerInfo returns metadata about the analyzer (e.g., list of policies contained).
        async fn get_analyzer_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::AnalyzerInfo>, tonic::Status>;
        /// GetPluginInfo returns generic information about this plugin, like its version.
        async fn get_plugin_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status>;
        /// Configure configures the analyzer, passing configuration properties for each policy.
        async fn configure(
            &self,
            request: tonic::Request<super::ConfigureAnalyzerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// `Handshake` is the first call made by the engine to an analyzer. It is used to pass the engine's address to the
        /// analyzer so that it may establish its own connections back, and to establish protocol configuration that will be
        /// used to communicate between the two parties.
        async fn handshake(
            &self,
            request: tonic::Request<super::AnalyzerHandshakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzerHandshakeResponse>,
            tonic::Status,
        >;
        /// `ConfigureStack` is always called if the engine is using the analyzer to analyze resources in a specific stack.
        /// This method is not always called, for example if the engine is just booting the analyzer up to call
        /// GetAnalyzerInfo.
        async fn configure_stack(
            &self,
            request: tonic::Request<super::AnalyzerStackConfigureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnalyzerStackConfigureResponse>,
            tonic::Status,
        >;
        /// Cancel signals the analyzer to gracefully shut down and abort any ongoing analysis operations.
        /// Operations aborted in this way will return an error. Since Cancel is advisory and non-blocking,
        /// it is up to the host to decide how long to wait after Cancel is called before (e.g.)
        /// hard-closing any gRPC connection.
        async fn cancel(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    /// Analyzer provides a pluggable interface for checking resource definitions against some number of
    /// resource policies. It is intentionally open-ended, allowing for implementations that check
    /// everything from raw resource definitions to entire projects/stacks/snapshots for arbitrary
    /// issues -- style, policy, correctness, security, and so on.
    #[derive(Debug)]
    pub struct AnalyzerServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AnalyzerServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AnalyzerServer<T>
    where
        T: Analyzer,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.Analyzer/Analyze" => {
                    #[allow(non_camel_case_types)]
                    struct AnalyzeSvc<T: Analyzer>(pub Arc<T>);
                    impl<T: Analyzer> tonic::server::UnaryService<super::AnalyzeRequest>
                    for AnalyzeSvc<T> {
                        type Response = super::AnalyzeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnalyzeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::analyze(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AnalyzeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/AnalyzeStack" => {
                    #[allow(non_camel_case_types)]
                    struct AnalyzeStackSvc<T: Analyzer>(pub Arc<T>);
                    impl<
                        T: Analyzer,
                    > tonic::server::UnaryService<super::AnalyzeStackRequest>
                    for AnalyzeStackSvc<T> {
                        type Response = super::AnalyzeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnalyzeStackRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::analyze_stack(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AnalyzeStackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/Remediate" => {
                    #[allow(non_camel_case_types)]
                    struct RemediateSvc<T: Analyzer>(pub Arc<T>);
                    impl<T: Analyzer> tonic::server::UnaryService<super::AnalyzeRequest>
                    for RemediateSvc<T> {
                        type Response = super::RemediateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnalyzeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::remediate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemediateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/GetAnalyzerInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyzerInfoSvc<T: Analyzer>(pub Arc<T>);
                    impl<T: Analyzer> tonic::server::UnaryService<()>
                    for GetAnalyzerInfoSvc<T> {
                        type Response = super::AnalyzerInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::get_analyzer_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyzerInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/GetPluginInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetPluginInfoSvc<T: Analyzer>(pub Arc<T>);
                    impl<T: Analyzer> tonic::server::UnaryService<()>
                    for GetPluginInfoSvc<T> {
                        type Response = super::PluginInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::get_plugin_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPluginInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/Configure" => {
                    #[allow(non_camel_case_types)]
                    struct ConfigureSvc<T: Analyzer>(pub Arc<T>);
                    impl<
                        T: Analyzer,
                    > tonic::server::UnaryService<super::ConfigureAnalyzerRequest>
                    for ConfigureSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConfigureAnalyzerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::configure(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConfigureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/Handshake" => {
                    #[allow(non_camel_case_types)]
                    struct HandshakeSvc<T: Analyzer>(pub Arc<T>);
                    impl<
                        T: Analyzer,
                    > tonic::server::UnaryService<super::AnalyzerHandshakeRequest>
                    for HandshakeSvc<T> {
                        type Response = super::AnalyzerHandshakeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnalyzerHandshakeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::handshake(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HandshakeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/ConfigureStack" => {
                    #[allow(non_camel_case_types)]
                    struct ConfigureStackSvc<T: Analyzer>(pub Arc<T>);
                    impl<
                        T: Analyzer,
                    > tonic::server::UnaryService<super::AnalyzerStackConfigureRequest>
                    for ConfigureStackSvc<T> {
                        type Response = super::AnalyzerStackConfigureResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnalyzerStackConfigureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::configure_stack(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConfigureStackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Analyzer/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: Analyzer>(pub Arc<T>);
                    impl<T: Analyzer> tonic::server::UnaryService<()> for CancelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Analyzer>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AnalyzerServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.Analyzer";
    impl<T> tonic::server::NamedService for AnalyzerServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
